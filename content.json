{"meta":{"title":"Rychou'blog","subtitle":"Knowledge & Life things!","description":null,"author":"Rychou","url":"rychou.github.io"},"pages":[{"title":"About","date":"2018-11-17T06:45:04.381Z","updated":"2018-11-17T06:45:04.381Z","comments":true,"path":"about/index.html","permalink":"rychou.github.io/about/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-11-17T06:45:04.385Z","updated":"2018-11-17T06:45:04.385Z","comments":true,"path":"tags/index.html","permalink":"rychou.github.io/tags/index.html","excerpt":"","text":""},{"title":"Project","date":"2018-11-17T06:45:04.383Z","updated":"2018-11-17T06:45:04.383Z","comments":true,"path":"project/index.html","permalink":"rychou.github.io/project/index.html","excerpt":"","text":""}],"posts":[{"title":"简谈文件下载的三种方式","slug":"简谈文件下载的三种方式","date":"2018-11-05T06:23:29.000Z","updated":"2018-11-17T12:36:09.406Z","comments":true,"path":"2018/11/05/简谈文件下载的三种方式/","link":"","permalink":"rychou.github.io/2018/11/05/简谈文件下载的三种方式/","excerpt":"","text":"一、前言本文章将以excel报表下载为例，给大家介绍三种文件下载的方式。 二、正文1. 通过服务器文件地址下载这是最常见的文件下载方式，大多数网站的音频、视频、种子文件等文件的下载方式都是通过这种方式实现的。 这种方式具体的实现方式是这样的： 前端请求获取excel报表的下载地址 后端根据前端的请求，查询数据库并把查询结果保存到服务器的一个excel文件中 后端把这个excel文件地址返回给前端 前端将此excel文件地址赋值给一个&lt;a href=&quot;http://test.com/excel.xls&quot;/&gt;,并点击此&lt;a/&gt;标签，利用浏览器的默认行为下载此文件。 优点：实现方式简单，通用。缺点：需要把文件保存到服务器，会占用服务器资源。这个缺点也有解决方式：给保存的文件设定一个时效性，过了这个时效，服务器就会删除这个文件。 2. 通过二进制数据流的方式下载这种方式是我目前采用的方式，用于处理报表下载。 这种方法的具体实现流程如下： 前端请求获取excel报表的二进制数据流 后端根据前端请求，查询数据库并把查询结果转成二进制数据流。注意：这里并不生成一个文件保存在服务器 后端把二进制数据流返回给前端 前端把二进制数据流转成URL对象并赋值给&lt;a/&gt;标签 点击&lt;a/&gt;标签实现下载 我用的是axios网络请求库 代码示例： 123456789101112131415161718axios(&#123; url: '/monitors/export', method: 'GET', responseType: 'blob' //指定返回数据格式&#125;).then(res =&gt; &#123; // 将二进制数据流转成URL对象 const url = window.URL.createObjectURL( new Blob([res.data], &#123; type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;charset=utf-8' &#125;) ) const link = document.createElement('a') link.href = url link.setAttribute('download', '车辆监控列表.xls') // 需要指定文件格式。 document.body.appendChild(link) link.click() //点击事件&#125;) 优点：不需要服务器生成文件，并保存到服务器中，可以有效减少服务器资源占用。缺点：这种方式可能并不那么通用，也可能有一定的兼容性问题。 3. 前端下载这种方式是我测试过，确实可行的一种方法，它的具体实现原理是这样的，前端通过类似export-from-json的库，把JSON格式的报表数据，导出到excel文件中。 优点：不需要为下载单独发起一次网络请求，直接把保存在前端的请求的报表数据，导出到excel文件即可。缺点：对于数据量不大的文件，这种方式是可行的。但是对于数据量很大，像几千几万条数据的话，性能缓慢是它最大的弊端。","categories":[],"tags":[{"name":"文件下载","slug":"文件下载","permalink":"rychou.github.io/tags/文件下载/"}]},{"title":"mpvue中小程序云开发总结","slug":"mpvue中小程序云开发总结","date":"2018-10-10T06:23:29.000Z","updated":"2018-11-17T12:35:14.866Z","comments":true,"path":"2018/10/10/mpvue中小程序云开发总结/","link":"","permalink":"rychou.github.io/2018/10/10/mpvue中小程序云开发总结/","excerpt":"一、前言这两天在用踩坑了一下小程序云开发，用 mpvue、vant 组件库、wux 组件库、小程序云开发开发了一款小程序。算是初试云开发了，所以总结一下使用上的注意事项。","text":"一、前言这两天在用踩坑了一下小程序云开发，用 mpvue、vant 组件库、wux 组件库、小程序云开发开发了一款小程序。算是初试云开发了，所以总结一下使用上的注意事项。 二、开启云开发功能 确保你的微信开发工具是最新版的小程序云开发文档 1. 注册一个小程序账号小程序云开发必须有小程序 AppId 才能使用，所以首先应先注册一个小程序账号（如果已有请忽略）。记录下设置-&gt;开发设置中的小程序AppId 2. 用mpvue初始化一个项目 参考：mpvue 官方文档 1234567891011# 全局安装 vue-cli$ npm install --global vue-cli# 创建一个基于 mpvue-quickstart 模板的新项目$ vue init mpvue/mpvue-quickstart my-project# 安装依赖$ cd my-project$ npm install# 启动构建$ npm run dev 2. 在微信开发者工具中新建项目新建项目选择的目录为dist目录，然后填写刚刚注册的小程序的AppId。 打开项目之后，可以发现开发者工具中多了个云开发的按钮。点击之后，安装提示配置，就可以了。微信默认免费提供开发者一个服务器进行云开发，对于小型程序来说是够用了。 三、正式使用云开发1. 开发前的配置首先在src/main.js文件添加以下语句。 123wx.cloud.init(&#123; traceUser: true&#125;) 必须要初始化才能使用云开发，traceUser决定是否在将用户访问记录到用户管理中，在控制台中可见。 2. 初试数据库云开发的数据库是一个JSON数据库，这里使用了查询数据的功能。 添加数据 首先得有数据，你可以在程序里进行插入数据（提交表单时使用）（参考云开发的文档），也可以手动的在云开发控制台中插入数据。 我直接在控制台插入数据好了。 在控制台的数据库中，点击添加集合-&gt;填入集合名称-&gt;在集合中点击添加纪录-&gt;添加所需的数据。这种插入数据的方式，是不带有用户态的(openId)，如果你的权限设置是管理员可读的话，那是没办法读取到信息的，因为没有 openId，没办法识别你的身份。 千万记住，要考虑你的集合数据的使用范围进行权限设置，比如我添加的是article文章，那这是公开的。那我就应该在权限设置中修改为所有用户可读、仅管理员可写，默认的是仅创建者及管理员可读写。 查询数据 12345678910mounted&#123; // env是你云开发的环境id。 const db = wx.cloud.database(&#123; env: 'meow-helper-1b5609' &#125;) this.db.collection('article').get() .then(res=&gt;&#123; console.log(res.data) // 可以进行数据初始化 &#125;) .cathc(console.error)&#125; 可以看到，使用方法很简单，当然你也可以使用回调的方式查询数据，具体参考云开发文档。 3. 云开发下的登录流程云开发大大简化了登录流程，因为每当有用户访问时，都会在云开发控制台留下该用户的openId。所以，我处理登录流程如下： 使用&lt;button&gt;&lt;/button&gt;组件获取用户授权 使用云函数从后端返回用户openId (待会会讲如何使用云函数) 如果同时有openId以及用户是否授权，那么就登录了 若用户授权了，那么你能在云开发控制台的用户管理中看到用户信息，否则只能看到一条记录以及openId 4.云函数的使用这里讲解如何通过云函数返回用户的openId 配置云函数根目录 在/static目录下创建目录funtions，然后在project.config.json文件下新增字段 123&#123; \"cloudfunctionRoot\": \"/static/functions/\"&#125; 注意：这可能在编译后不会生效，保险起见，应在npm run dev后检查dist/project.config.json文件，看看刚刚的字段是否添加成功，如果没有，请在dist/project.config.json中也添加上述字段。 新增云函数 新增云函数这一步必须得在微信开发者工具中进行。 打开开发者工具 在编辑器窗口下，右键/static/funtions，选择新建 Node 云函数 填写云函数名,如user，回车。 在弹出的窗口中，会询问你是否安装wx-server-sdk，点击确定（如果安装没有进行，可以自己手动在命令行中运行npm install） 完成以上步骤后就可以在index.js中编写云函数了。以下的云函数代码用于返回用户openId 123456789// 云函数入口文件const cloud = require('wx-server-sdk')cloud.init()// 云函数入口函数exports.main = async (event, context) =&gt; &#123; return event.userInfo&#125; 编写完成后，一定要记得右键云函数目录，选择上传并部署之后，才能使用云函数。 使用云函数 1234567891011121314151617// 调用云函数，返回用户openId，参数为云函数名称wx.cloud .callFunction(&#123; name: 'user' &#125;) .then(res =&gt; &#123; console.log(res) // 更新store中的openId this.$store.commit('updateOpenId', res.result) return this.WXP.getSetting() &#125;) .then(res =&gt; &#123; // 检验是否授权 const authUserInfo = res.authSetting['scope.userInfo'] if (authUserInfo) &#123; this.$store.commit('updateAuthUserInfo', authUserInfo) &#125; &#125;) .catch(err =&gt; console.error(err)) 5.存储的使用云开发的存储具有上传，下载，删除等功能，具体可以查看云开发文档。 它支持直接在&lt;image/&gt;,&lt;audio/&gt;等组件中直接使用云文件 id。接下来演示一下。 首先我们手动在云存储中上传一张图片，然后复制其fileId 在需要用到的地方引入即可： 1&lt;image src=\"cloud://meow-helper-1b5609.6d65-meow-helper-1b5609/img/13.png\"/&gt; 四、总结小程序云开发是属于最近刚出来的技术，目的是为了简化小程序的开发。特别适合于业务逻辑简单，功能不复杂的小程序。对于那些比如说电商平台等业务逻辑复杂的小程序，目前来说可能不适合了。 这个是我用云开发写的一个小程序，欢迎大家使用，提供建议。 猫叫助手 | 收录各种猫叫声，帮助与猫咪交流，分享一些养猫的小知识等。","categories":[],"tags":[{"name":"小程序","slug":"小程序","permalink":"rychou.github.io/tags/小程序/"},{"name":"mpvue","slug":"mpvue","permalink":"rychou.github.io/tags/mpvue/"},{"name":"云开发","slug":"云开发","permalink":"rychou.github.io/tags/云开发/"}]},{"title":"用Promise实现小程序接口链式调用","slug":"用Promise实现小程序接口链式调用","date":"2018-10-06T06:23:29.000Z","updated":"2018-11-17T12:34:12.129Z","comments":true,"path":"2018/10/06/用Promise实现小程序接口链式调用/","link":"","permalink":"rychou.github.io/2018/10/06/用Promise实现小程序接口链式调用/","excerpt":"","text":"一、前言 作者平时使用mpvue开发小程序，所以下面讲到的方法都是基于mpvue而言的，当然本质上原生小程序语法同样适用 大家都知道，小程序的接口都是采用回调的方式，这样如果代码逻辑复杂了，将会导致代码难以阅读。今天就通过ES6的Promise函数，来稍微改造一下小程序接口，让我们的代码实现链式调用，便于阅读。 二、核心代码在utils目录下新建文件WXP.js（WX Promise）,代码内容如下： 1234567891011121314151617181920// 代码核心，利用到了ES6的Promise函数function f(func, obj) &#123; return new Promise((resolve, reject) =&gt; &#123; func(&#123; ...obj, success: resolve, fail: reject &#125;) &#125;)&#125;// 改写所有wx接口var WX = &#123;&#125;for (let key in wx) &#123; WX[key] = obj =&gt; f(wx[key], obj)&#125;//将改写后的导出export default WX 代码原理很简单，主要就是在代码回调的地方，分别调用resolve和reject函数，分别对应着success和fail回调 三、在顶层main.js下全局配置WXP.js123456789101112// main.jsimport Vue from 'vue'import App from './App'import WXP from './utils/wxp'Vue.config.productionTip = falseApp.mpType = 'app'Vue.prototype.WXP = WXPconst app = new Vue(App)app.$mount() 这么做主要是全局配置之后，就不需要每个文件里面都导入WXP.js文件，便于使用。 四、使用改造前的回调方式： 12345678910111213141516wx.showLoading(&#123; title: '测试', success: function() &#123; wx.login(&#123; success: function(res) &#123; console.log(res.code) &#125;, fail: function(err) &#123; console.error(err) &#125; &#125;) &#125;, fail: function(err) &#123; console.error(err) &#125;&#125;) 改造后的链式调用方式 12345678this.WXP.showLoading(&#123; title: '测试' &#125;) .then(res =&gt; &#123; return this.WXP.login() &#125;) .then(res =&gt; &#123; console.log(res.code) &#125;) .catch(err =&gt; console.error(err)) 可以看出来，当回调的方式层次不深的时候还是便于阅读的，但是异步操作多了，层次就会多，这样代码就会变得难以阅读。而改造后的链式调用方式，不管你层次有多少，都是一条链一样，一步一步的，思路清晰，易于阅读。不得不说，Promise大法好哈哈哈哈哈哈哈哈哈 参考连接：小程序 API大白话讲解 Promise阮大佬的 Promise","categories":[],"tags":[{"name":"小程序","slug":"小程序","permalink":"rychou.github.io/tags/小程序/"},{"name":"mpvue","slug":"mpvue","permalink":"rychou.github.io/tags/mpvue/"},{"name":"Promise","slug":"Promise","permalink":"rychou.github.io/tags/Promise/"}]},{"title":"Linux操作系统下连接闪讯的方法（支持有线与无线）","slug":"Linux操作系统下连接闪讯的方法","date":"2018-10-05T06:23:29.000Z","updated":"2018-11-17T12:33:02.632Z","comments":true,"path":"2018/10/05/Linux操作系统下连接闪讯的方法/","link":"","permalink":"rychou.github.io/2018/10/05/Linux操作系统下连接闪讯的方法/","excerpt":"一、前言用过电信闪讯的同学都知道，闪讯没有开发 Linux 的客户端程序，所以这让很多玩 Linux 操作系统同时又是闪讯用户的同学很头疼，今天我就来介绍一下如何在 Linux 下连接闪讯网络，并且支持有线连接和无线连接。","text":"一、前言用过电信闪讯的同学都知道，闪讯没有开发 Linux 的客户端程序，所以这让很多玩 Linux 操作系统同时又是闪讯用户的同学很头疼，今天我就来介绍一下如何在 Linux 下连接闪讯网络，并且支持有线连接和无线连接。 本教材基于这个Github仓库shanxun_pppoe_linux_desktop 二、使用教程1. 克隆此仓库到本地shanxun_pppoe_linux_desktop 2. 安装 ppp 依赖1sudo apt-get install ppp 3. 修改或确认 makefile 文件的 TODO 项makefile 中的 TODO 项都有相关的注释，不同的系统可能有不同的配置，应先确认。 4. 安装和编译在仓库目录下执行： 123sudo chmod a+x INSTALLsudo ./INSTALL zhejiang_xiaoyuan_sxplugin#(其他地区请更换,地区列表在makefile内) 5. 连接闪讯网络由于闪讯网络有两种方式连接，有线和无线，方法略有不同。 首先在命令行执行ifconfig命令，记录下有线网卡和无线网卡名称，有线网卡名称是e开头的，无线网卡名称是w开头的，不同设备的名称不一样。 5.1 有线连接 直接使用以下命令连接有线： 1sudo connect_sx &lt;username&gt; &lt;password&gt; 参数分别是闪讯用户名和密码 12345678# 其后直接使用这个命令就可以了sudo connect_sx# 更改密码sudo connect_sx &lt;password&gt;# 断开连接sudo connect_sx stop 若连接不上，则尝试以下命令后再次尝试连接。 123sudo del default routesudo add default route &lt;有线网卡名称&gt;sudo connect_sx &lt;username&gt; &lt;password&gt; 5.2 无线连接 使用以下命令连接 1pppd noauth nodetach defaultroute usepeerdns maxfail 1 user &lt;your username&gt; password &lt;your password&gt; mtu 1492 mru 1492 plugin rp-pppoe.so nic-&lt;网卡名&gt; plugin zhejiang_xiaoyuan_sxplugin.so 需要配置的参数有用户名和密码，以及你的无线网卡名，此方法也可以用来连接有线，在网卡名填入对应的有线网卡名即可。 三、连接脚本针对以上连接方式，为了便于连接，我写了以下脚本，仅供参考。 12345678910111213141516171819202122232425262728#!/bin/bash# 是否连接有线ETH_STATE=`cat /sys/class/net/enp4s0/operstate`# 是否连接无线WLAN_STATE=`cat /sys/class/net/wlp1s0/operstate`# 连接的无线网络名称 其中wlp1s0是无线网卡名WLAN_NAME=`iwconfig wlp1s0 | grep ESSID | awk -F\\\" '&#123;print $2&#125;'`# 账号密码username=12345678911@DZKD.XYpassword=123456# 有线连接if [ \"up\" == $ETH_STATE ]then connect_sxfi# 无线连接if [ \"up\" == $WLAN_STATE ]then # 我所在环境能连闪讯的有三个无线WIFI if [ \"ChinaNet-shanxun\" == $WLAN_NAME ]||[ \"ChinaNet-tRmt\" == $WLAN_NAME ]||[ \"ChinaNet-tRmt-5G\" == $WLAN_NAME ] then pppd noauth nodetach defaultroute usepeerdns maxfail 1 user $username password $password mtu 1492 mru 1492 plugin rp-pppoe.so nic-wlp1s0 plugin zhejiang_xiaoyuan_sxplugin.so else echo \"is not shanxun\" fifi 在后台运行脚本： 1sudo nohup ./shanxun.sh &amp;","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"rychou.github.io/tags/Linux/"},{"name":"闪讯","slug":"闪讯","permalink":"rychou.github.io/tags/闪讯/"}]},{"title":"ES6数组去重和重复元素统计","slug":"ES6数组去重和重复元素统计","date":"2018-09-27T06:23:29.000Z","updated":"2018-11-17T12:32:27.360Z","comments":true,"path":"2018/09/27/ES6数组去重和重复元素统计/","link":"","permalink":"rychou.github.io/2018/09/27/ES6数组去重和重复元素统计/","excerpt":"","text":"一、去重这里利用到了ES6的Set结构不允许数据重复的特性 123let arr1 = [1, 1, 2, 3, 1, 2, 4, 2]//先将数组转化为Set数据类型，然后再转回数组类型let dedupeArr = Array.from(new Set(arr1)) 二、统计123456789let count = 0let obj = &#123;&#125; //最终返回的数据dedupeArr.forEach(i =&gt; &#123; count = 0 arr1.forEach(j =&gt; &#123; if (i === j) count++ &#125;) obj[i] = count //键名为i(数组元素)，值为count(出现次数)&#125;) 三、遍历对象12345678for(let i = 0 in obj)&#123; console.log(i+':'+obj[i]);&#125;// 数组元素:出现次数// 1:3// 2:3// 3:1// 4:1","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"rychou.github.io/tags/Javascript/"}]},{"title":"Js学习笔记：回调函数","slug":"Js学习笔记之回调函数","date":"2018-09-18T06:23:29.000Z","updated":"2018-11-17T11:32:12.125Z","comments":true,"path":"2018/09/18/Js学习笔记之回调函数/","link":"","permalink":"rychou.github.io/2018/09/18/Js学习笔记之回调函数/","excerpt":"A callback is a function that is passed as an argument to another function and is executed after its parent function has completed。 回调函数作为参数传递给另外一个函数，当另外一个函数执行完后再执行这个传递进去的函数（回调函数）。","text":"A callback is a function that is passed as an argument to another function and is executed after its parent function has completed。 回调函数作为参数传递给另外一个函数，当另外一个函数执行完后再执行这个传递进去的函数（回调函数）。 这里我看到一个网上一个很有意思的例子 约会结束后你送你女朋友回家，离别时，你肯定会说：“到家了给我发条信息，我很担心你。” 对不，然后你女朋友回家以后还真给你发了条信息。小伙子，你有戏了。其实这就是一个回调的过程。你留了个参数函数（要求女朋友给你发条信息）给你女朋友，然后你女朋友回家，回家的动作是主函数。她必须先回到家以后，主函数执行完了，再执行传进去的函数，然后你就收到一条信息了。 1234567891011function A(callback) &#123; callback() console.log('1')&#125;function B() &#123; setTimeout(console.log('2'), 3000)&#125;A(B)//输出//1//2 这里回调函数 B 是一个需要等待 3 秒才输出的，然而主函数不必等回调函数 B 执行完毕，可以继续执行自己的代码，然后再去执行回调函数 B。 所以回调函数一般用来做一些耗时的操作，如网络请求等，来实现异步操作。","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"rychou.github.io/tags/Javascript/"},{"name":"踩坑","slug":"踩坑","permalink":"rychou.github.io/tags/踩坑/"},{"name":"回调函数","slug":"回调函数","permalink":"rychou.github.io/tags/回调函数/"}]},{"title":"Js学习笔记：闭包","slug":"Js学习笔记之闭包","date":"2018-09-02T06:23:29.000Z","updated":"2018-11-17T12:30:06.732Z","comments":true,"path":"2018/09/02/Js学习笔记之闭包/","link":"","permalink":"rychou.github.io/2018/09/02/Js学习笔记之闭包/","excerpt":"一、前言这个周末，注意力都在学习基础 Js 知识上面，刚好看到了闭包这个神圣的东西，所以打算把这两天学到的总结下来，算是巩固自己所学。也可能有些不正确的地方，也请大家看到了，麻烦在评论下提醒一下，算是互相学习了。","text":"一、前言这个周末，注意力都在学习基础 Js 知识上面，刚好看到了闭包这个神圣的东西，所以打算把这两天学到的总结下来，算是巩固自己所学。也可能有些不正确的地方，也请大家看到了，麻烦在评论下提醒一下，算是互相学习了。 二、什么是闭包？ 百度百科定义：闭包就是能够读取其他函数内部变量的函数。 在解释之前，得先讲讲作用域。先来看下面这个示例： 123456var a = 1;function f()&#123; var b = 2; console.log(a) // 1&#125;console.log(b) // undefined 示例中包含了两种作用域，一种是属于全局的全局作用域，另一种是属于函数f的局部作用域。由于Javascript这种链式作用域(父作用域是可以被其子作用域访问的，而子作用域却不能被父作用域访问)的机制，使得示例最后一行输出了undefined 从此可以看出，无法从父作用域中访问子作用域。而我们再来看闭包的定义：闭包就是能够读取其他函数内部变量的函数。也就是闭包可以让我们从父作用域中访问到子作用域，具体怎么实现的呢？来看这个经典的例子： 1234567891011function foo()&#123; var a = 2; function bar()&#123; console.log(a); &#125; return bar;&#125;var baz = foo();baz(); // 2 -&gt; 这就是闭包的效果 这个示例中，闭包就是函数bar。可以看到，我们通过在函数foo内部定义其子函数bar，并将其作为foo返回值，因为bar函数作用域可以访问foo的作用域，所以实现了从全局作用域访问foo函数作用域的效果。 三、闭包的应用其实，平时你所写的代码中，早就用到了闭包，只是你还没发现而已。 本质上，无论何时何地，如果将函数当作值传递到其他地方使用（非函数所在作用域），你就已经使用了闭包。例如上面示例说的函数bar，我们将他传递到了全局作用域下，通过这种方式访问到本该不能访问的变量a。 在定时器、事件监听器、Ajax 请求、任何其他异步（或同步）任务中，只要使用了回调函数，实际上就是在使用闭包！ 四、注意事项闭包会让他所在作用域中的变量始终保存在内存中，而不会被垃圾回收机制回收。 12345678910111213141516171819function foo(p)&#123; function bar()&#123; console.log(++p); &#125; return bar;&#125;var baz = foo(1);baz(); // 2baz(); // 3baz(); // 4var bazz = foo(2);bazz(); // 3bazz(); // 4bazz(); // 5baz(); // 5 看到了没，闭包的使用，函数调用之后，让其外层函数的内部变量(foo函数内的变量)始终保存在了内存中，而不会被回收。 值得注意的是，每次调用一次foo，都会生成一个新的闭包，都会在内存中保存下其外层函数的内部变量。因此要注意闭包的使用，否则会导致性能问题。 五、总结闭包的作用： 能够读取其他函数内部变量。 让其他函数的内部变量始终保存在内存中。 参考： 阮一峰的 Javascript 入门教程——闭包 书籍：P43，你不知道的 Javascript 之闭包——上卷。 附：你不知道的 Javascript 系列电子书网盘链接， 密码：i8jf","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"rychou.github.io/tags/Javascript/"},{"name":"闭包","slug":"闭包","permalink":"rychou.github.io/tags/闭包/"}]},{"title":"Mpvue中使用Vant Weapp组件库","slug":"Mpvue中使用Vant Weapp组件库","date":"2018-08-31T06:25:08.000Z","updated":"2018-11-17T10:15:46.670Z","comments":true,"path":"2018/08/31/Mpvue中使用Vant Weapp组件库/","link":"","permalink":"rychou.github.io/2018/08/31/Mpvue中使用Vant Weapp组件库/","excerpt":"一、介绍mpvue-vant记录了我们团队开发中在mpvue中使用Vant Weapp组件库所踩下的坑，在这里分享给大家，让mpvue开发者可以使用vant组件库进行开发，避免踩不必要的坑。","text":"一、介绍mpvue-vant记录了我们团队开发中在mpvue中使用Vant Weapp组件库所踩下的坑，在这里分享给大家，让mpvue开发者可以使用vant组件库进行开发，避免踩不必要的坑。 此教程是在dov-yih一同协助下完成。经过测试，Vant Weapp下所有组件都能够在mpvue中使用 demo 地址 更新日志 二、使用方法 目前 vant 已经支持了npm的方式，但是由于node_modules目录下的代码是不会被编进dist目录下的，所以暂时只能用git方式使用。 克隆 vant 仓库将dist目录下的所有文件复制到你项目的/static/vant/目录下。 1git clone https://github.com/youzan/vant-weapp.git 12// 当然你也可以克隆本仓库代码，本仓库会与`vant`仓库保持同步。直接将`vant`目录复制到`/static`目录下git clone https://github.com/xxxsimons/mpvue-vant.git 引入在需要引入的页面目录下的main.json文件中 12345&#123; \"usingComponents\": &#123; \"van-button\": \"/static/vant/button/index\", &#125;&#125; 使用1&lt;van-button&gt;测试&lt;/van-button&gt; 三、注意事项具体组件 api 文档参考Vant Weapp 1. 使用方式mpvue 和原生小程序的方式有所不同。可以参考mpvue 文档 1.1 数据绑定原生小程序使用方式为 1value=\"&#123;&#123;value&#125;&#125;\" mpvue 使用方式 123v-bind:value=\"value\"//或者:value=\"value\" 1.2 事件监听原生小程序使用方式 1bind:click=\"onClick\" mpvue 使用方式 1@click=\"onClick\" 1.3 vue 中组件引入vant中像notify这种操作反馈类的组件都有两个引入，一是组件的引入，这个在main.json中引入；另一个是方法的引入，需要在vue文件中import引入，值得注意的是，这里的引入不能使用绝对路径，可以用类似于这样的相对路径。 1import Notify from '@/../static/notify/notify' //@是mpvue的一个别名，指向src目录 1.4 获取 event值得注意的是，mpvue中获取event值与原生小程序有所不同。举例： 123onChange(event)&#123; // 获取表单组件filed的值 console.log(event.mp.detail) // 注意加入mp&#125; 2. BUG 及报错处理方法2.1 监听名mpvue 里面无法使用@click-icon这样的监听名,因此如果 API 文档里面有出现这样的监听名，那么需要手动修改源代码。 可以改成驼峰式的监听名。 eg: 我在field组件中就遇到这个问题，我的做法是： 1234567// static/vant/field/index.jsthis.$emit('click-icon');// 修改为:this.$emit('clickIcon'); 2.2 报错一般的报错报错都可以通过一下流程处理。 是否打开了微信开发者工具中的ES6转ES5功能。 仔细检查代码和比对文档，看看是否有使用不当的地方。 重新编译npm run dev或删掉dist目录重新npm run dev 重启或更新微信开发者工具。 若以上流程都走完了，还是无法解决报错，可以通过提交issues的方式，我来帮你解决。 2.2.1 引入组件报错1VM54:1 thirdScriptError sdk uncaught third Error module \"static/vant/notify/index.js\" is not defined 解决办法是：打开小程序开发者工具中的ES6 转 ES5功能. issues/#5 3. 其他组件库目前比较好的组件库有三个，Wux Weapp,iview weapp,Vant Weapp。 这三者都是用原生小程序写的组件库，因此理论上来说，在 mpvue 中都是可以无缝使用的。不同组件库的组件都不一样，有的更丰富，有的逻辑更完善，有的文档更清晰。因此用什么组件，还需要自己取舍。 比如：三者中，唯有Wux Weapp有日历组件，而且它里面还有一些更高级的组件可以使用。 使用方法上，几乎没有差异。值得注意的是，大家复制源代码到自己项目上时，应该复制/dist/目录下的文件。因为这里是经过编译后的。 如果大家使用过程中遇到什么 BUG，可以通过提issues的方式让我知道，大家一起踩坑吧！ 分享一个 Demo作者基于 vant 和 wux 组件库,以及最新的小程序云开发开发的一个小程序。以及总结了mpvue中使用云开发的注意事项，mpvue-cloud 猫叫助手|收录各种猫叫声，帮助与猫咪交流，分享一些养猫的小知识等。","categories":[],"tags":[{"name":"mpvue","slug":"mpvue","permalink":"rychou.github.io/tags/mpvue/"},{"name":"vant","slug":"vant","permalink":"rychou.github.io/tags/vant/"}]},{"title":"小程序分享功能报错问题解决方案","slug":"小程序分享功能报错问题解决方案","date":"2018-08-30T06:25:08.000Z","updated":"2018-11-17T10:13:55.214Z","comments":true,"path":"2018/08/30/小程序分享功能报错问题解决方案/","link":"","permalink":"rychou.github.io/2018/08/30/小程序分享功能报错问题解决方案/","excerpt":"报错信息12345678910111213thirdScriptErrorCannot read property 'apply' of null;at pages/client/home/main page onShareAppMessage functionTypeError: Cannot read property 'apply' of null at t.l (http://127.0.0.1:62595/appservice/__dev__/WAService.js:18:30625) at dn (http://127.0.0.1:62595/appservice/__dev__/WAService.js:20:2360) at Function.pn (http://127.0.0.1:62595/appservice/__dev__/WAService.js:20:3321) at http://127.0.0.1:62595/appservice/__dev__/WAService.js:19:1368 at http://127.0.0.1:62595/appservice/__dev__/WAService.js:20:4179 at n (http://127.0.0.1:62595/appservice/__dev__/WAService.js:6:8644) at a (http://127.0.0.1:62595/appservice/appservice?t=1535626735316:3056:9566) at e.registerCallback (http://127.0.0.1:62595/appservice/appservice?t=1535626735316:3056:9753) at n.forEach (http://127.0.0.1:62595/appservice/appservice?t=1535626735316:3056:5638) at Array.forEach (&lt;anonymous&gt;)","text":"报错信息12345678910111213thirdScriptErrorCannot read property 'apply' of null;at pages/client/home/main page onShareAppMessage functionTypeError: Cannot read property 'apply' of null at t.l (http://127.0.0.1:62595/appservice/__dev__/WAService.js:18:30625) at dn (http://127.0.0.1:62595/appservice/__dev__/WAService.js:20:2360) at Function.pn (http://127.0.0.1:62595/appservice/__dev__/WAService.js:20:3321) at http://127.0.0.1:62595/appservice/__dev__/WAService.js:19:1368 at http://127.0.0.1:62595/appservice/__dev__/WAService.js:20:4179 at n (http://127.0.0.1:62595/appservice/__dev__/WAService.js:6:8644) at a (http://127.0.0.1:62595/appservice/appservice?t=1535626735316:3056:9566) at e.registerCallback (http://127.0.0.1:62595/appservice/appservice?t=1535626735316:3056:9753) at n.forEach (http://127.0.0.1:62595/appservice/appservice?t=1535626735316:3056:5638) at Array.forEach (&lt;anonymous&gt;) 原因这是因为你将onShareAppMessage()这个页面级的方法写到组件中导致的错误，解决办法就是将其写到页面内。","categories":[],"tags":[{"name":"小程序","slug":"小程序","permalink":"rychou.github.io/tags/小程序/"}]},{"title":"小程序输入框闪烁BUG解决方案","slug":"小程序输入框闪烁BUG解决方案","date":"2018-08-30T06:25:08.000Z","updated":"2018-11-17T10:14:37.683Z","comments":true,"path":"2018/08/30/小程序输入框闪烁BUG解决方案/","link":"","permalink":"rychou.github.io/2018/08/30/小程序输入框闪烁BUG解决方案/","excerpt":"前言 本人所说的小程序，都是基于mpvue框架而上的，因此BUG可能是原生小程序的，也有可能是mpvue的。","text":"前言 本人所说的小程序，都是基于mpvue框架而上的，因此BUG可能是原生小程序的，也有可能是mpvue的。 问题描述在小程序input组件中，如果使用v-model进行双向绑定，在输入时会出现光标闪烁的BUG。 原因造成这个 BUG 的原因，是因为在原生小程序input组件上，进行了封装。才导致光标闪烁的问题。 解决方案这里提供了两种解决方案。各有各的优势，请选取合适的方案： 一、弃用v-model,使用@input适用于input组件单纯是用户手动输入的，而没有像授权获取手机号，然后自动填入input组件中。这种需要赋予初始value的情况。即适用于单向绑定，而不是双向绑定。 123456789101112131415161718192021222324252627282930/*** 父组件*/// html&lt;childInput @input=\"onInput\"/&gt; &lt;-- 注意这里不能使用:value=value赋予初始值，否则又会出现闪烁的BUG，因为此时就等同于v-model了// jsimport ChildInput from './ChildInput'export default &#123; components:&#123; ChildInput &#125;, data()&#123; return &#123; value:'' &#125; &#125;, methods()&#123; onInput(e)&#123; this.value = e &#125; &#125;&#125;/*** 子组件 ChildInput*/// html&lt;input @input=\"$emit('input',$event)\"/&gt; 二、不封装input组件，直接使用v-model这种情况就是可以直接双向绑定的了。具体原因还不清楚，可能是本身原生小程序的 BUG。 123456789101112131415/*** 父组件,不使用封装的子组件，直接使用原生组件。*/// html&lt;input v-model=\"value\"/&gt;// jsexport default &#123; data()&#123; return &#123; value:'' &#125; &#125;&#125;","categories":[],"tags":[{"name":"小程序","slug":"小程序","permalink":"rychou.github.io/tags/小程序/"}]},{"title":"为你的博客添加目录索引","slug":"为你的博客添加目录索引","date":"2018-08-21T06:25:08.000Z","updated":"2018-11-17T10:08:31.677Z","comments":true,"path":"2018/08/21/为你的博客添加目录索引/","link":"","permalink":"rychou.github.io/2018/08/21/为你的博客添加目录索引/","excerpt":"一、前言演示图例","text":"一、前言演示图例 需求这个目录索引应该包含以下功能： 点击目录项跳转到对应锚点 屏幕滚动时，对应目录项样式变化 话不多说，开始干！ 二、点击目录项跳转到对应锚点hash 模式的路由下的锚点说到文章的目录索引，首先想到的就是锚点了。然而在hash模式的路由下，如果使用原始的锚点方案会造成下面这样的问题。 123456// 文章url链接,hash模式下www.rychou.xyz/#/article/70// 如果采用传统的锚点方式，比如有个锚点：anchor-1，点击之后，url会变成www.rychou.xyz/#anchor-1 很明显，在hash模式下，就不能采用这种方式锚点了。我采用了自定义锚点的方式。 参考：vue2.0 中怎么做锚点定位 添加锚点和初始化目录的数据结构方法有了，然后就是怎么给文章加添加锚点了。 我采用了遍历 dom 树，然后找到文章的h1标签（暂时只对h1标签建立索引），为其添加id的方式建立索引。 1234567891011// 初始化文章锚点和目录数据结构getDirectories() &#123; let directories = document.querySelectorAll(\".article-content h1\"); //找到属于文章内容的h1标签 directories.forEach((element, index) =&gt; &#123; element.id = \"anchor-\" + index;//添加id this.directories.push(&#123; title: element.innerText, //h1标签文本内容 offsetTop: element.offsetTop, //记录当前h1标签的偏移量，方便后面计算滚动距离。 isActive: false //是否被选中 &#125;); &#125;); 实现点击跳转到对应锚点123456789101112&lt;div v-for=\"(item,index) in directories\" :key=\"index\"&gt; &lt;a href=\"javascript:void(0)\" @click=\"goAnchor(index)\" &gt; &#123;&#123;item.title&#125;&#125; &lt;/a&gt;&lt;/div&gt;methods:&#123; goAnchor(index) &#123; document.documentElement.scrollTop = this.directories[index].offsetTop; &#125;,&#125; 三、屏幕滚动时，对应目录项样式变化注意我们前面初始化目录数据结构中，包含了一个叫isActive的状态位，就是根据这个状态位来进行相应的渲染 动态绑定class12345678910&lt;div class=\"directories-container\"&gt; &lt;div class=\"directories-list\"&gt; &lt;h2&gt;目录&lt;/h2&gt; &lt;div :class=\"&#123;'highlight-title':item.isActive&#125;\" v-for=\"(item,index) in directories\" :key=\"index\" style=\"padding: 5px 12px;\"&gt; &lt;a href=\"javascript:void(0)\" @click=\"goAnchor(index)\" &gt; &#123;&#123;item.title&#125;&#125; &lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 添加滚动监听12345678// 挂载页面时，添加滚动监听mounted() &#123; window.addEventListener(\"scroll\", this.handleScroll); &#125;,// 退出页面时，应该取消监听destroyed() &#123; window.removeEventListener(\"scroll\", this.handleScroll);&#125;, 计算状态位isActive12345678910111213handleScroll(e) &#123; let scrollTop = document.documentElement.scrollTop //当前滚动距离 this.directories.forEach((element,index)=&gt;&#123; if((scrollTop)&gt;=element.offsetTop)&#123;//当前滚动距离大于某一目录项时。 for(let i=0;i&lt;index;i++)&#123; this.directories[i].isActive = false //同一时刻，只能有一个目录项的状态位为Active，即此时其他目录项的isActive = false &#125; element.isActive = true; //将对应的目录项状态位置为true &#125;else&#123; element.isActive = false; &#125; &#125;)&#125; css 样式12345678910111213141516171819202122232425262728// scss.directories-container &#123; width: 15vw; transition: all 0.5s; margin-left: 10px; .highlight-title &#123; border-left: 3px solid rgb(15, 105, 223); background-color: rgb(243, 243, 243); z-index: -1; a&#123; color: rgb(15, 105, 223) &#125; &#125; .directories-list &#123; position: -webkit-sticky; position: sticky; top: 0; word-wrap: break-word; background-color: #fff; border-left: 1px solid rgb(236, 236, 236); z-index: 999; a &#123; &amp;:hover &#123; text-decoration: underline; &#125; &#125; &#125;&#125;","categories":[],"tags":[{"name":"目录","slug":"目录","permalink":"rychou.github.io/tags/目录/"}]},{"title":"用gitalk给你的博客添加评论服务","slug":"用gitalk给你的博客添加评论服务","date":"2018-08-18T06:28:03.000Z","updated":"2018-11-17T10:06:49.978Z","comments":true,"path":"2018/08/18/用gitalk给你的博客添加评论服务/","link":"","permalink":"rychou.github.io/2018/08/18/用gitalk给你的博客添加评论服务/","excerpt":"一、前言不像 hexo、jekyll 等，为了学习，我的博客是用vue和nodejs搭建出来的。支持在线编辑和 markdown 渲染等功能。 大家如果感兴趣可以看我的博客地址 最近给自己的博客添加了评论服务，用到的评论服务是Gitalk，它是基于github issue搭建出来的评论系统。废话不多说，接下来说说如何使用。","text":"一、前言不像 hexo、jekyll 等，为了学习，我的博客是用vue和nodejs搭建出来的。支持在线编辑和 markdown 渲染等功能。 大家如果感兴趣可以看我的博客地址 最近给自己的博客添加了评论服务，用到的评论服务是Gitalk，它是基于github issue搭建出来的评论系统。废话不多说，接下来说说如何使用。 二、必要的准备在 Github 创建一个用来存放评论的仓库当然你也可以直接用你博客所在的仓库，因为我的博客部署到了coding pages，所以我单独创建了一个仓库用来存放评论。 注册一个Github OAuth application没有的可以点这里申请 注册成功后，记录下你的clientID和clientSecret。 三、安装有两种方式安装(CDN 和 npm)，大家可自行选择。 1. CDN1234567&lt;link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css\"&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js\"&gt;&lt;/script&gt;&lt;!-- or --&gt;&lt;link rel=\"stylesheet\" href=\"https://unpkg.com/gitalk/dist/gitalk.css\"&gt;&lt;script src=\"https://unpkg.com/gitalk/dist/gitalk.min.js\"&gt;&lt;/script&gt; 2. npm1npm i --save gitalk 四、使用考虑到vue的生命周期等，使用方法上和官方文档给出来的是需要做略微的调整的。 引入 gitalk123456//在index.html页面中CDN引入&lt;link rel=\"stylesheet\" href=\"https://unpkg.com/gitalk/dist/gitalk.css\"&gt;&lt;script src=\"https://unpkg.com/gitalk/dist/gitalk.min.js\"&gt;//在vue中importimport Gitalk from 'gitalk' 初始化 Gitalk 实例123456789101112131415export default &#123; data()&#123; return&#123; gitalk: new Gitalk(&#123; clientID: \"你的clientID\", clientSecret: \"你的clientSecret\", repo: \"刚刚创建的项目名\", owner: \"github用户名\", admin: [\"github用户名\"], id: window.location.hash, // 默认为pathname,如果你也是像我这样用vue搭建的，我建议使用hash，原因具体后面会讨论到。 distractionFreeMode: false // Facebook-like distraction free mode &#125;) &#125; &#125;&#125; 在恰当的位置添加标签,用来渲染 Gitalk 组件。1&lt;div id=\"gitalk-container\"&gt;&lt;/div&gt; 渲染123mounted()&#123; this.gitalk.render(\"gitalk-container\");&#125; 五、注意事项id 的设置这个 id 是用来唯一区分页面的，也就是你不同的文章肯定有不同的评论数据，Gitalk要通过这个 id 来区分是哪个页面，然后在你的github仓库创建相应的issue来存放当页评论数据，id默认值是window.location.pathname 但是默认的只适用于采用history模式的路由，但对于vue-router这种默认采用hash模式的就不行了。 举个例子 123456789//在history模式下，路由URL如下格式www.rychou.xyz/article/69window.location.pathname;// 值是 /article/69//在hash模式下，路由变成这样了www.rychou.xyz/#/article/69window.location.pathname; // 值是 / 此时，在hash模式下id就不具有唯一性了。 建议使用window.location.hash，此时的值是#/aticle/69,具有唯一性。 当然你也可以设置vue-router为history模式，但是这会有一个刷新页面出现 404 的 BUG，解决办法参考官方文档 不使用类似的评论服务Gitment的原因我也试过用Gitment，也成功了，但是有一个非常令人不爽的地方，就是每一篇文章都需要手动初始化(创建相应 issue)，因此我还是用了Gitalk,它会根据你的配置，自动帮你初始化。 六、最后有问题的同学们，欢迎来原文下方提问，同时也相当于帮我测试一下评论服务了。 参考链接： Gitalk Gitment 官方文档- vue-router History 模式","categories":[],"tags":[{"name":"Gitalk","slug":"Gitalk","permalink":"rychou.github.io/tags/Gitalk/"}]},{"title":"用shelljs实现前端部署自动化","slug":"用shelljs实现前端部署自动化","date":"2018-08-17T06:28:03.000Z","updated":"2018-11-17T10:06:53.923Z","comments":true,"path":"2018/08/17/用shelljs实现前端部署自动化/","link":"","permalink":"rychou.github.io/2018/08/17/用shelljs实现前端部署自动化/","excerpt":"一、场景在前端开发过程中，你肯定经常使用到以下等命令： 1234npm run buildgit add .git commit -m 'commit'git push","text":"一、场景在前端开发过程中，你肯定经常使用到以下等命令： 1234npm run buildgit add .git commit -m 'commit'git push 本人在用vue-cli写我的个人博客时，将其部署到coding pages上。不用github pages的原因纯粹是因为慢。。。每一次部署，都要将上面的命令敲一遍，实在令我很痛苦。如果能用一条命令执行以上所有任务，那就爽多了。 话不多说，说干就干。 二、Shelljs这个库能够让我们在js文件中执行 shell 命令，具体可以看文档。 安装1npm install [-g] shelljs 有两种使用方式，一种是全局模式(对应全局安装),一种是局部模式。看下面的使用案例就知道两者区别。 三、使用在根目录下新建文件shell.js，内容如下： 1234567891011121314151617//局部模式var shell = require('shelljs');//全局模式下，就不需要用shell开头了。//require('shelljs/global');if (shell.exec('npm run build').code !== 0) &#123;//执行npm run build 命令 shell.echo('Error: Git commit failed'); shell.exit(1);&#125;//由于我的用另外一个仓库存放dist目录，所以这里要将文件增量复制到目标目录。并切换到对应目录。shell.cp ('-r', './dist/*', '../../Rychou');shell.cd('../../Rychou');shell.exec('git add .');shell.exec(\"git commit -m 'autocommit'\")shell.exec('git push') 这时在根目录下执行node shell.js就可以了 这里只是最简单的使用案例。 四、再让它更方便些在package.json中加入： 123\"script\":&#123;+ \"push\":\"node ./shell.js\"&#125; 在根目录下执行npm run push就搞定了。 参考链接：Shelljs","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"rychou.github.io/tags/Javascript/"},{"name":"前端自动化","slug":"前端自动化","permalink":"rychou.github.io/tags/前端自动化/"}]},{"title":"Js学习笔记：apply与call","slug":"Js学习笔记之apply与call","date":"2018-08-15T06:32:20.000Z","updated":"2018-11-17T11:32:18.725Z","comments":true,"path":"2018/08/15/Js学习笔记之apply与call/","link":"","permalink":"rychou.github.io/2018/08/15/Js学习笔记之apply与call/","excerpt":"一、apply 与 call 的区别相同点：“可以让一个对象调用另一个对象的方法” 不同点： apply 最多只能传入两个参数，第一个为对象，第二个为数组 call 能传入多个参数，第一个为对象，其后为 n 个参数列表","text":"一、apply 与 call 的区别相同点：“可以让一个对象调用另一个对象的方法” 不同点： apply 最多只能传入两个参数，第一个为对象，第二个为数组 call 能传入多个参数，第一个为对象，其后为 n 个参数列表 实际上，apply 和 call 实现的功能是一样的，只是传入的参数不同而已。 示例: 12345678910111213function add(a,b)&#123; return a+b;&#125;function sub(a,b)&#123; return a-b;&#125;var a1 = add.apply(sub,[4,2]); //sub调用add的方法var a2 = sub.apply(add,[4,2]);alert(a1); //6alert(a2); //2/*call的用法*/var a1 = add.call(sub,4,2); apply 的一些使用技巧 配合Math.max()计算数组最大值 因为Math.max()不支持数组的方式，只能Math.max(a,b,c....)。根据 apply 的特点来实现这一功能，Math.max.apply(null,[1,2,3]),因为没有新的对象调用 Math 的 max 方法，所以只是传入 null 来利用 apply 的特性帮助进行计算而已。 apply 会将数组中的每个元素一个个传入给 Math.max()。也就相当于Math.max.call(null,1,2,3) 同理可以用Math.min.apply(null,[1,2,3])计算数组最小值 配合 Array.prototype.push 实现两个数组合并 数组的 push 方法是不能 push 数组的，但是可以同时 push 多个元素，因此可以利用 apply 的特性 1234var a = [1,2,3];var b = [4,5,6];Array.prototype.push.apply(a,b);//apply会将为b中每一个元素执行一次push方法。返回值是push后数组a的长度 参考链接:apply()与 call()的区别 二、Object.prototype.toString.call()进行类型检验首先来看一个问题，用 typeof 来检验类型有什么缺点呢？ 答案是 typeof 无法准确地检验对象类型。 12typeof null //objecttypeof [] //object null的类型是object，这是由于历史原因造成的。1995 年的 JavaScript 语言第一版，只设计了五种数据类型（对象、整数、浮点数、字符串和布尔值），没考虑null，只把它当作object的一种特殊值。后来null独立出来，作为一种单独的数据类型，为了兼容以前的代码，typeof null返回object就没法改变了。 比较好的方式就是用 Object.prototype.toString.call()来进行检验。 12345678910var a = &#123;&#125;;var b = [];var c = 1;Object.prototype.toString.call(a);//[object,Object]Object.prototype.toString.call(b);//[object,Array]Object.prototype.toString.call(c);//[object,Number]//判断a是否是对象类型Object.prototype.toString.call(a) === \"[object,Object]\" 注意：使用 obj.toString()是不能得到类型的。原因：Array,Function 等类型作为 Object 的实例，都重写的了 toString 方法。因此在调用时，是调用了重写后的方法，而不是原型链上的 toString()方法 123456var arr=[1,2,3];console.log(Array.prototype.hasOwnProperty(\"toString\"));//trueconsole.log(arr.toString());//1,2,3delete Array.prototype.toString;//delete操作符可以删除实例属性console.log(Array.prototype.hasOwnProperty(\"toString\"));//falseconsole.log(arr.toString());//\"[object Array]\" 删除了重写的方法后，使用 obj.toString()也就相当于调用原型链的方法了，即 Object.prototype.toString.call() 参考链接: 为什么用 Object.prototype.toString.call(obj)检测对象类型? 深入理解 Object.prototype.toString.call()","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"rychou.github.io/tags/Javascript/"}]},{"title":"小程序实现长按录音，上划取消发送","slug":"小程序实现长按录音,上划取消发送","date":"2018-07-23T06:28:03.000Z","updated":"2018-11-17T11:32:30.291Z","comments":true,"path":"2018/07/23/小程序实现长按录音,上划取消发送/","link":"","permalink":"rychou.github.io/2018/07/23/小程序实现长按录音,上划取消发送/","excerpt":"最近在使用 mpvue 开发小程序，需要用到录音功能，于是打算参照微信的录音方案：”长按录音松开发送，上划取消发送”。在网上找了一圈都没发现相似的案例，没办法只能自己实现。 下面讲解只贴上关键代码","text":"最近在使用 mpvue 开发小程序，需要用到录音功能，于是打算参照微信的录音方案：”长按录音松开发送，上划取消发送”。在网上找了一圈都没发现相似的案例，没办法只能自己实现。 下面讲解只贴上关键代码 1. html 部分。微信小程序事件接口： 类型 触发条件 touchstart 手指触摸动作开始 touchmove 手指触摸后移动 touchend 手指触摸动作结束 longpress 手指触摸后，超过 350ms 再离开，如果指定了事件回调函数并触发了这个事件，tap 事件将不被触发 longtap 手指触摸后，超过 350ms 再离开（推荐使用 longpress 事件代替） 分析:长按录音需要 longpress 事件，松开发送需要 touchend 事件，上滑取消发送需要 touchmove 事件。由此可有以下 html 代码 12345//html部分 class部分只是控制样式 与功能无关&lt;div class=\"input weui-grid\" hover-class=\"weui-grid_active\" :class=\"record.type\" @longpress=\"handleRecordStart\" @touchmove=\"handleTouchMove\" @touchend=\"handleRecordStop\"&gt; &lt;image class=\"weui-grid__icon\" :src=\"record.iconPath\"/&gt; &lt;div class=\"weui-grid__label\"&gt;&#123;&#123;record.text&#125;&#125;&lt;/div&gt;&lt;/div&gt; 2. JS 部分2.1. 首先定义录音的数据结构：旧版的小程序录音接口 wx.startRecord 和 wx.stopRecord 在 1.6.0 版本后不再维护了，所以使用其建议的wx.getRecordManager接口。 注意:使用 wx.getRecordManager 接口的话,应调用相应的音频控制接口wx.createInnerAudioContext()来播放和控制录音. 123456789101112data()&#123; record: &#123; text: \"长按录音\", type: \"record\", iconPath: require(\"@/../static/icons/record.png\"), handler: this.handleRecordStart &#125;, //与录音相关的数据结构 recorderManager: wx.getRecorderManager(), //录音管理上下文 startPoint: &#123;&#125;, //记录长按录音开始点信息,用于后面计算滑动距离。 sendLock: true, //发送锁，当为true时上锁，false时解锁发送 &#125;, 2.2. 监听录音 stop123456789101112131415onLoad()&#123; this.recorderManager.onStop(res =&gt; &#123; if (this.sendLock) &#123; //上锁不发送 &#125; else &#123;//解锁发送，发送网络请求 if (res.duration &lt; 1000) wx.showToast(&#123; title: \"录音时间太短\", icon: \"none\", duration: 1000 &#125;); else this.contents = [...this.contents,&#123; type: \"record\", content: res &#125;];//contents是存储录音结束后的数据结构,用于渲染. &#125; &#125;);&#125; 2.3. 长按录音方法在这个方法中需要做的事: 记录长按的点信息,用于后面计算手指滑动的距离,实现上滑取消发送. 做一些界面样式的控制. 开始录音 123456789101112131415161718handleRecordStart(e) &#123; //longpress时触发 this.startPoint = e.touches[0];//记录长按时开始点信息，后面用于计算上划取消时手指滑动的距离。 this.record = &#123;//修改录音数据结构，此时录音按钮样式会发生变化。 text: \"松开发送\", type: \"recording\", iconPath: require(\"@/../static/icons/recording.png\"), handler: this.handleRecordStart &#125;; this.recorderManager.start();//开始录音 wx.showToast(&#123; title: \"正在录音，上划取消发送\", icon: \"none\", duration: 60000//先定义个60秒，后面可以手动调用wx.hideToast()隐藏 &#125;); this.sendLock = false;//长按时是不上锁的。 &#125;, 2.4. 松开发送在这个方法中需要做的事: 做一些样式的控制. 结束录音. 1234567891011handleRecordStop() &#123; // touchend(手指松开)时触发 this.record = &#123;//复原在start方法中修改的录音的数据结构 text: \"长按录音\", type: \"record\", iconPath: require(\"@/../static/icons/record.png\"), handler: this.handleRecordStart &#125;; wx.hideToast();//结束录音、隐藏Toast提示框 this.recorderManager.stop();//结束录音&#125; 2.5. 上划取消发送在这个方法中需要做的事: 计算手指上滑的距离 根据距离判断是否需要取消发送 如果取消发送,最重要的是 this.sendLock = true,上锁不发送 1234567891011121314151617181920 handleTouchMove(e) &#123; //touchmove时触发 var moveLenght = e.touches[e.touches.length - 1].clientY - this.startPoint.clientY; //移动距离 if (Math.abs(moveLenght) &gt; 50) &#123; wx.showToast(&#123; title: \"松开手指,取消发送\", icon: \"none\", duration: 60000 &#125;); this.sendLock = true;//触发了上滑取消发送，上锁 &#125; else &#123; wx.showToast(&#123; title: \"正在录音，上划取消发送\", icon: \"none\", duration: 60000 &#125;); this.sendLock = false;//上划距离不足，依然可以发送，不上锁 &#125; &#125;,&#125; 2.6. 演示 GIF","categories":[],"tags":[{"name":"小程序","slug":"小程序","permalink":"rychou.github.io/tags/小程序/"},{"name":"录音","slug":"录音","permalink":"rychou.github.io/tags/录音/"},{"name":"mpvue","slug":"mpvue","permalink":"rychou.github.io/tags/mpvue/"}]},{"title":"vue和小程序踩坑指南","slug":"vue和小程序踩坑指南","date":"2018-07-19T06:25:08.000Z","updated":"2018-11-17T06:27:12.610Z","comments":true,"path":"2018/07/19/vue和小程序踩坑指南/","link":"","permalink":"rychou.github.io/2018/07/19/vue和小程序踩坑指南/","excerpt":"一、参考文档 小程序官方 Api 文档 mpvue 官方文档 vue 官方文档","text":"一、参考文档 小程序官方 Api 文档 mpvue 官方文档 vue 官方文档 二、工具篇1. VSCode 插件 Eslint 格式化代码插件，在写代码时提示格式以及保存代码时自动格式化代码。配置教程 mpvue snippets 小程序和 mpvue 代码提示 Vetur Vue 开发工具 2. normalize 前端解析 Json APIa:{ 1:{ type:&#39;&#39;, id:&#39;&#39; } } 对于这种对象的key为数字的，然而并不知道数字是啥，可以使用a[Object.keys(a)[0]]来访问第一个元素 3. mpvue-router-patch在 mpvue 中使用 vue-router 的写法4. flyio 发起网络请求5. 封装小程序 API，实现异步调用// WXP.js // 核心 function f (func, obj) { return new Promise((resolve, reject) =&gt; { func({ ...obj, success: resolve, fail: reject }) }) } export default { // 获取认证 code login: obj =&gt; f(wx.login, obj), } //使用 import WXP from &#39;WXP&#39; WXP.login({}) .then(res=&gt;{}) .catch(err=&gt;{}) 6. Promise 实现 finally.// 安装 npm i --save promise.prototype.finally // main.js引入 require(&#39;promise.prototype.finally&#39;).shim(); // 使用 promise()//某个异步操作 .then() .catch() .finally() 三、踩坑1.修改 v-html 渲染的标签样式不生效的问题产生原因：在中加了 scoped 属性，这个属性的作用是让样式私有化（只在本组件生效）。而使用了 v-html 之后，其实际是被当成子组件了，因此导致样式不生效 解决办法：去掉中的 scoped &lt;template&gt; &lt;div v-html=&quot;htmlString&quot;&gt;&lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default{ data(){ return(){ htmlString:&#39;&#39;//要渲染的html字符串 } } } &lt;/script&gt; &lt;style lang=&quot;scss&quot;&gt;//去掉scoped &lt;/style&gt; 2. 如何在 vue 中使用 hightlight.js 高亮你的代码安装 highlight.jsnpm install highlight.js --save 在顶层 main.js 中加入以下代码段import hljs from &#39;highlight.js&#39; import &#39;highlight.js/styles/monokai.css&#39;//样式文件 //vue自定义指令，检索所有的code标签进行高亮 Vue.directive(&#39;highlight&#39;,function (el) { let blocks = el.querySelectorAll(&#39;code&#39;); blocks.forEach((block)=&gt;{ hljs.highlightBlock(block) }) }) 在你文章的顶层标签加入自定义指令 v-highlight&lt;div class=&quot;article-body&quot; v-html=&quot;compileMarkdown&quot; v-highlight&gt;&lt;/div&gt; 3. 不要在 computed 内使用 split()方法4.wx.showToast({title:’text’,image:’/state/xx.png’})需要用绝对路径5. &lt;scroll-view&gt;&lt;/scroll-view&gt;组件5.1. 如若需要竖向滚动，则需要设置固定高度，并且单位不能为 rpx（设置成 rpx 会有显示的问题，显示不全）&lt;scroll-view :scroll-y=&quot;true&quot; :style=&quot;{&#39;height&#39;: scrollHeight+&#39;px;&#39;,&#39;padding-top&#39;:&#39;100rpx&#39;}&quot; //切不要设置成rpx，否则会出现显示不全的bug :enable-back-to-top=&quot;true&quot; @scrolltolower=&quot;loadData&quot; &gt; ... &lt;/scroll-view&gt; //获取屏幕高度 wx.getSystemInfo({ success: res =&gt; { this.scrollHeight = parseInt(res.windowHeight); } }); 5.2.使用&lt;scroll-view&gt;&lt;/scroll-view&gt;组件与onPullDownRefresh不能同时使用参考：微信小程序—下拉刷新上拉加载 6. 录音6.1. 格式问题导致录音无法播放。小程序推荐使用的录音管理上下文wx.getRecorderManager()支持的录音格式有两种:aac/mp3。如果不指定格式，在安卓端录音的文件格式是 m4a 的，会导致无法播放。 所以需要在录音时手动设置格式为mp3格式，aac会有播放不全的 BUG this.recordManager.start({ format: &#39;mp3&#39; // })","categories":[],"tags":[{"name":"踩坑","slug":"踩坑","permalink":"rychou.github.io/tags/踩坑/"},{"name":"小程序","slug":"小程序","permalink":"rychou.github.io/tags/小程序/"},{"name":"Vue","slug":"Vue","permalink":"rychou.github.io/tags/Vue/"}]},{"title":"小程序Tabs懒加载","slug":"小程序Tabs懒加载","date":"2018-07-17T06:26:31.000Z","updated":"2018-11-17T06:27:31.564Z","comments":true,"path":"2018/07/17/小程序Tabs懒加载/","link":"","permalink":"rychou.github.io/2018/07/17/小程序Tabs懒加载/","excerpt":"小程序用 mpvue 编写 v-if 和:hidden 的区别这两种方式都可以用来控制组件的显示与隐藏，但他们实现原理上有所不同。","text":"小程序用 mpvue 编写 v-if 和:hidden 的区别这两种方式都可以用来控制组件的显示与隐藏，但他们实现原理上有所不同。 v-if：这是条件渲染，只有当其为 true 时，才会渲染出来:hidden：这只是控制组件的显示与隐藏，会将所有组件都在开始的时候全部加载，只是有的组件没有显示而已。 v-if 有更高的切换消耗（切换会有旧组件销毁和新组件挂载），而 hidden 有更高的初始渲染消耗（在初始就挂载所有组件）。所以 hidden 更适合用于频繁切换 使用 hidden 实现懒加载 在父组件用 hidden 控制组件隐藏显示 index.vue//父组件 ---------------------------- ... &lt;template&gt; &lt;div class=&quot;weui-tab__panel&quot;&gt; &lt;div class=&quot;weui-tab__content&quot; :hidden=&quot;hiddens[index]&quot; v-for=&quot;(tab,index) in tabs&quot; :key=&quot;index&quot; &gt;//在tab内容组件外面一层用hidden控制组件隐藏 &lt;list-delegate :hidden=&quot;hiddens[index]&quot;/&gt;//这里将hidden属性传入tab内容子组件内部，其内部根据hidden进行相关的控制。 &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; ... &lt;script&gt; export default{ data(){ return(){ tabs: [&quot;推荐&quot;, &quot;热门&quot;, &quot;我的&quot;], activeIndex: 0, } } computed: { hiddens(){ return [this.activeIndex!=0,this.activeIndex!=1,this.activeIndex!=2]//hiddens数组，计算当前hidden的tab，一共有3个tab } ........ } &lt;/script&gt; -------------------------------------- 2.在 tab 内容子组件用传入的 hidden 属性进行相关的控制","categories":[],"tags":[{"name":"踩坑","slug":"踩坑","permalink":"rychou.github.io/tags/踩坑/"},{"name":"小程序","slug":"小程序","permalink":"rychou.github.io/tags/小程序/"}]},{"title":"在富文本编辑器之外使用quill富文本样式","slug":"在富文本编辑器之外使用quill富文本样式","date":"2018-07-17T04:37:17.000Z","updated":"2018-11-17T06:22:05.098Z","comments":true,"path":"2018/07/17/在富文本编辑器之外使用quill富文本样式/","link":"","permalink":"rychou.github.io/2018/07/17/在富文本编辑器之外使用quill富文本样式/","excerpt":"在将使用富文本编辑器时遇到了一个这样的问题：如何在富文本编辑器 VueEditor 之外依然能够有原来的样式 一开始的思路是全局引入 quill 的样式文件，因为 VueEditor 是基于 quill 的一个富文本编辑器","text":"在将使用富文本编辑器时遇到了一个这样的问题：如何在富文本编辑器 VueEditor 之外依然能够有原来的样式 一开始的思路是全局引入 quill 的样式文件，因为 VueEditor 是基于 quill 的一个富文本编辑器 npm install quill@1.3.6 //先安装quill //在main.js引入样式文件 import &#39;quill/dist/quill.core.css&#39; import &#39;quill/dist/quill.snow.css&#39; import &#39;quill/dist/quill.bubble.css&#39; 结果发现依然行不通，通过查看 quill 的样式文件发现 //quill/dist/quill.snow.css .ql-snow .ql-editor pre.ql-syntax { //这是富文本编辑器中代码段（code）的样式 background-color: #23241f; color: #f8f8f2; overflow: visible; } 样式文件是使用了父元素控制的，而通过富文本编辑器生成的 html 字符串中，是没有包含父元素的，因此在要渲染 html 的元素中给他嵌套父元素以及赋予相应的 class 就可以了！ &lt;div class=&quot;ql-container ql-snow&quot; style=&quot;border:none&quot;&gt; &lt;div class=&quot;ql-editor&quot;&gt; &lt;div v-html=&quot;article.content&quot;&gt;&lt;/div&gt; //这是渲染html字符串的元素，其余是给他嵌套的父元素 &lt;/div&gt; &lt;/div&gt; 参考链接：https://segmentfault.com/q/1010000012313485","categories":[],"tags":[{"name":"踩坑","slug":"踩坑","permalink":"rychou.github.io/tags/踩坑/"},{"name":"vue","slug":"vue","permalink":"rychou.github.io/tags/vue/"}]},{"title":"发布你的第一个npm包！","slug":"2017-12-6","date":"2017-12-06T12:23:28.000Z","updated":"2017-12-06T15:38:32.345Z","comments":true,"path":"2017/12/06/2017-12-6/","link":"","permalink":"rychou.github.io/2017/12/06/2017-12-6/","excerpt":"1. 新建代码库 比如用的是github，那么在github上面创一个库，库的名字用你想发布的npm包名就好了。 2. clone到本地 3. 在本地库运行npm init 按照提示依次输入信息，如果有不想输入的话直接回车就好了。最终生成的package.json文件内容如下：","text":"1. 新建代码库 比如用的是github，那么在github上面创一个库，库的名字用你想发布的npm包名就好了。 2. clone到本地 3. 在本地库运行npm init 按照提示依次输入信息，如果有不想输入的话直接回车就好了。最终生成的package.json文件内容如下： { &quot;name&quot;: &quot;rycou-test&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;a test&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: { &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; }, &quot;repository&quot;: { &quot;type&quot;: &quot;git&quot;, &quot;url&quot;: &quot;https://git.coding.net/rychouuuu/test-npm-install.git&quot; }, &quot;keywords&quot;: [ &quot;test&quot; ], &quot;author&quot;: &quot;rychou&quot;, &quot;license&quot;: &quot;ISC&quot; } 这里还需要一个入口文件，我这里用的是默认的index.js。在本地库里面新建文件index.js,内容如下： exports.showMsg = function () { console.log(&quot;This is my first module&quot;); }; 然后把本地库git push到远程库。 4. 发布npm包 4.1 首先要在官网注册一个账号,npm注册4.2 如果是第一次登陆的话，要在本地运行npm login，登陆一下。 $npm login Username: (你注册的时候的Username) Email: (你的注册邮箱) 4.3 运行npm publish发布包，发布之后去官网(npm)搜一下你的包是否发布成功。 发布过程中你可能会遇到错误： error 1： 使用cnpm的报错处理方法： 换回npm的镜像 npm config set registry http://registry.npmjs.org //发布之后改回淘宝镜像就好了 npm config set registry https://registry.npm.taobao.org error 2: 邮箱未认证处理方法： 去官网登陆后，会弹出一个是否发送邮箱的认证，点击发邮箱去自己的邮箱点击链接认证，然后再发布就好了 其他错误： 遇到其他错误的话，google查一下。 5. 用自己刚刚发布的包 5.1 在本地新建一个空目录，然后 npm install (你发布的包名) 5.2 新建index.js，内容： var test = require(&#39;你的包名&#39;); test.showMsg(); 5.3 node index.js 5.4 运行结果： This is my first module 恭喜你成功了","categories":[],"tags":[{"name":"npm","slug":"npm","permalink":"rychou.github.io/tags/npm/"}]},{"title":"C++中的引用转化为C语言的指针","slug":"2017-11-27","date":"2017-11-27T13:02:49.000Z","updated":"2017-11-29T15:07:23.279Z","comments":true,"path":"2017/11/27/2017-11-27/","link":"","permalink":"rychou.github.io/2017/11/27/2017-11-27/","excerpt":"C++中引用符号&amp;转化为C语言的指针*的方法最近在写数据结构上机作业时，在网上借鉴(抄)其他人的源代码时，发现有些C语言代码中夹杂着C++的代码，比如这个C++的引用符&amp;就让我很头疼，因为C中没有引用这个概念。其实在C++中是可以完美运行的，但是我又不想在C++里运行，就想怎样让其在C中运行呢。经过百般努力，终于成功了。","text":"C++中引用符号&amp;转化为C语言的指针*的方法最近在写数据结构上机作业时，在网上借鉴(抄)其他人的源代码时，发现有些C语言代码中夹杂着C++的代码，比如这个C++的引用符&amp;就让我很头疼，因为C中没有引用这个概念。其实在C++中是可以完美运行的，但是我又不想在C++里运行，就想怎样让其在C中运行呢。经过百般努力，终于成功了。 typedef struct{ Triple data[MAXSIZE+1]; int rpos[MAXRC+1]; int mu,nu,tu; }RLSMatrix; Status InitSMatrix(RLSMatrix &amp;M,RLSMatrix &amp;N){ int p; for(p=1;p&lt;=M-&gt;tu;p++){ printf(&quot;输入行号：&quot;); scanf(&quot;%d&quot;,&amp;M.data[p].i); printf(&quot;输入列号：&quot;); scanf(&quot;%d&quot;,&amp;M.data[p].j); printf(&quot;输入元素值：&quot;); scanf(&quot;%d&quot;,&amp;M.data[p].e); } ..... } void main(){ RLSMatrix M N; InitSMatrix(M,N); } 上面这段是在C++里的代码，&amp;指的是引用。这代码在C中是跑不起来的，接下来我们做一些改动，让它在C语言跑起来 typedef struct{ Triple data[MAXSIZE+1]; int rpos[MAXRC+1]; int mu,nu,tu; }RLSMatrix; Status InitSMatrix(RLSMatrix *M,RLSMatrix *N){//&amp;换为* int p; for(p=1;p&lt;=M-&gt;tu;p++){ printf(&quot;输入行号：&quot;); scanf(&quot;%d&quot;,&amp;M-&gt;data[p].i);//.换成-&gt; printf(&quot;输入列号：&quot;); scanf(&quot;%d&quot;,&amp;M-&gt;data[p].j);//.换成-&gt; printf(&quot;输入元素值：&quot;); scanf(&quot;%d&quot;,&amp;M-&gt;data[p].e);//.换成-&gt; } ..... } void main(){ RLSMatrix M N; InitSMatrix(&amp;M,&amp;N);//对M,N取址&amp; } 这样我们的代码就可以在C中完美运行啦！！！","categories":[],"tags":[{"name":"C++ C","slug":"C-C","permalink":"rychou.github.io/tags/C-C/"}]},{"title":"学习React的心理路程","slug":"React-Study","date":"2017-11-15T13:52:16.000Z","updated":"2017-11-15T14:06:59.498Z","comments":true,"path":"2017/11/15/React-Study/","link":"","permalink":"rychou.github.io/2017/11/15/React-Study/","excerpt":"","text":"教程链接 React视频教程,密码：8dwj React中文文档 一个网友写的比较好的教程 心路历程一开始直接看老师发过来的一些电子书，看到前面一两章已经初步了解到React的强大，但是不能自己动手实践做一些demo感觉还是很虚，单纯看书也记不住。所以就自己找了一些网课的教程，其中一个就是文章开头贴上去的视频教程。视频里面有5个部分左右吧，每个部分都是直接动手写demo，并且边写边给你解释。刚开始我就是照着视频里的demo一点点写下来（切忌复制黏贴源码，虽然感觉看懂了，但是记忆不深刻），慢慢的就入门了。遇到问题再去网上找，查文档。总结下来我学习的过程就是：看视频—&gt;写视频里的demo—&gt;遇到不懂的问题，网上搜、查文档 最后的建议个人感觉入门一个语言不应该直接硬着头皮去看文档，应该直接动手写demo，写的过程中肯定会遇到很多问题，当你想方设法解决了这些问题之后，自然而然就入门了。(●’◡’●)加油！！！","categories":[],"tags":[]},{"title":"Js中splice()于slice()的区别","slug":"Javascript","date":"2017-11-06T15:48:33.000Z","updated":"2017-11-29T15:07:01.571Z","comments":true,"path":"2017/11/06/Javascript/","link":"","permalink":"rychou.github.io/2017/11/06/Javascript/","excerpt":"splice() 方法与 slice() 方法的作用是不同的，splice() 方法会直接对数组进行修改,可以删除元素，也可以插入元素。而slice()是返回已有数组中的选定元素，可以截取字符串。","text":"splice() 方法与 slice() 方法的作用是不同的，splice() 方法会直接对数组进行修改,可以删除元素，也可以插入元素。而slice()是返回已有数组中的选定元素，可以截取字符串。 splice()语法array.splice(start) array.splice(start, deleteCount) array.splice(start, deleteCount, item1, item2, ...) 示例 var myFish = [&quot;angel&quot;, &quot;clown&quot;, &quot;mandarin&quot;, &quot;surgeon&quot;]; //从第 2 位开始删除 0 个元素，插入 &quot;drum&quot; var removed = myFish.splice(2, 0, &quot;drum&quot;); //运算后的 myFish:[&quot;angel&quot;, &quot;clown&quot;, &quot;drum&quot;, &quot;mandarin&quot;, &quot;surgeon&quot;] //被删除元素数组：[]，没有元素被删除 //从第 3 位开始删除 1 个元素 removed = myFish.splice(3, 1); //运算后的myFish：[&quot;angel&quot;, &quot;clown&quot;, &quot;drum&quot;, &quot;surgeon&quot;] //被删除元素数组：[&quot;mandarin&quot;] //从第 2 位开始删除 1 个元素，然后插入 &quot;trumpet&quot; removed = myFish.splice(2, 1, &quot;trumpet&quot;); //运算后的myFish: [&quot;angel&quot;, &quot;clown&quot;, &quot;trumpet&quot;, &quot;surgeon&quot;] //被删除元素数组：[&quot;drum&quot;] //从第 0 位开始删除 2 个元素，然后插入 &quot;parrot&quot;, &quot;anemone&quot; 和 &quot;blue&quot; removed = myFish.splice(0, 2, &quot;parrot&quot;, &quot;anemone&quot;, &quot;blue&quot;); //运算后的myFish：[&quot;parrot&quot;, &quot;anemone&quot;, &quot;blue&quot;, &quot;trumpet&quot;, &quot;surgeon&quot;] //被删除元素的数组：[&quot;angel&quot;, &quot;clown&quot;] //从第 3 位开始删除 2 个元素 removed = myFish.splice(3, Number.MAX_VALUE); //运算后的myFish: [&quot;parrot&quot;, &quot;anemone&quot;, &quot;blue&quot;] //被删除元素的数组：[&quot;trumpet&quot;, &quot;surgeon&quot;] slice()语法array.slice(start, end) 示例 在数组中读取元素： var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Lemon&quot;, &quot;Apple&quot;, &quot;Mango&quot;]; var citrus = fruits.slice(1,3); 输出： Orange,Lemon 截取字符串 var str=&quot;www.runoob.com!&quot;; document.write(str.slice(4)+&quot;&lt;br&gt;&quot;); // 从第 5 个字符开始截取到末尾 document.write(str.slice(4,10)); // 从第 5 个字符开始截取到第10个字符","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"rychou.github.io/tags/Javascript/"}]},{"title":"给页面添加一个密码验证","slug":"给页面添加一个密码验证","date":"2017-10-18T16:05:29.000Z","updated":"2017-11-29T15:06:32.101Z","comments":true,"path":"2017/10/19/给页面添加一个密码验证/","link":"","permalink":"rychou.github.io/2017/10/19/给页面添加一个密码验证/","excerpt":"文章的密码验证今天写博客的时候想着要些一些日记之类的博客的话，如果没有密码验证那就不叫日记了，所以在网上找了一下方法，下面是我根据别人的改进的js代码,加在文章中可以实现密码验证","text":"文章的密码验证今天写博客的时候想着要些一些日记之类的博客的话，如果没有密码验证那就不叫日记了，所以在网上找了一下方法，下面是我根据别人的改进的js代码,加在文章中可以实现密码验证直接附上源码 &lt;script&gt; while(1){ if(&quot;123456&quot;==prompt(&quot;请输入密码！(123456)&quot;)) { break; } else { alert(&quot;输入错误&quot;); } } &lt;/script&gt; 注意事项： 使用时将该段代码放到文章开头，否则就会不起效果。什么意思呢？看下面图片就知道了。 看到了吧，如果放在文章末尾的话，就会先加载js代码前面的部分，也就是文章内容，所以说，为了防止这种情况发生，得把js代码放在文章开头 不过这个代码还是不完善的，比如说如果你的主题主页不是单纯的列表页的话，那么你在主页就会出现这个密码验证。所以说不完善，博主还在想办法完善中。不过我朋友找到一个插件可以设置密码，下面是我朋友的博客文章https://bababadboy.github.io/2017/10/18/AES%E5%8A%A0%E5%AF%86hexo%E6%96%87%E7%AB%A0/ while(1){ if(\"123456\"==prompt(\"请输入密码！(123456)\")) { break; } else { alert(\"输入错误\"); } }","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"rychou.github.io/tags/hexo/"}]},{"title":"hexo建站的坑","slug":"hexo建站的坑","date":"2017-10-18T15:14:05.000Z","updated":"2017-11-29T15:07:12.748Z","comments":true,"path":"2017/10/18/hexo建站的坑/","link":"","permalink":"rychou.github.io/2017/10/18/hexo建站的坑/","excerpt":"Hexo的安装与使用这是我的第一篇博客，刚开始想弄jekyll的，但是弄了很久也没配置好，干脆直接弄hexo了。接下来讲讲我弄hexo的遇到的一些问题吧。这是一个我看到的一个比较好的教程","text":"Hexo的安装与使用这是我的第一篇博客，刚开始想弄jekyll的，但是弄了很久也没配置好，干脆直接弄hexo了。接下来讲讲我弄hexo的遇到的一些问题吧。这是一个我看到的一个比较好的教程大家在配置好后，在本地运行一般没有问题，但是在推到Github上去的时候， $ hexo deploy Error：Deployer not found: git 我就遇到了这里出错的问题，在网上看了解决办法发现只需要在你的Blog的根目录下运行一下代码 npm install hexo-deployer-git --save 然后再 $ hexo generate $ hexo deploy 然后everything is ok！","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"rychou.github.io/tags/hexo/"}]}]}