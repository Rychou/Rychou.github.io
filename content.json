{"meta":{"title":"Rychou'blog","subtitle":"Knowledge & Life things!","description":null,"author":"Rychou","url":"rychou.github.io"},"pages":[{"title":"About","date":"2018-11-17T06:45:04.381Z","updated":"2018-11-17T06:45:04.381Z","comments":true,"path":"about/index.html","permalink":"rychou.github.io/about/index.html","excerpt":"","text":""},{"title":"Project","date":"2018-11-17T06:45:04.383Z","updated":"2018-11-17T06:45:04.383Z","comments":true,"path":"project/index.html","permalink":"rychou.github.io/project/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-11-17T06:45:04.385Z","updated":"2018-11-17T06:45:04.385Z","comments":true,"path":"tags/index.html","permalink":"rychou.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"前后端对接","slug":"前后端对接","date":"2019-04-16T04:37:17.000Z","updated":"2019-04-16T09:03:41.427Z","comments":true,"path":"2019/04/16/前后端对接/","link":"","permalink":"rychou.github.io/2019/04/16/前后端对接/","excerpt":"","text":"前后端对接的流程 大学生前端学习路线 基本 HTML/CSS/JS 至少学会使用一门前端框架（React/Vue） 参与实际项目开发（竞赛/接项目） 前端面试经验 基础知识 HTML/CSS/JS 刷面试题 参加面试并记录面试过程中的问题（如果没有面试经验，推荐先投中小型公司练练经验） 根据自己面试中遇到的不足及时补上","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"rychou.github.io/tags/前端/"}]},{"title":"操作DOM节点","slug":"DOM操作","date":"2019-03-15T14:05:29.000Z","updated":"2019-03-15T12:55:04.771Z","comments":true,"path":"2019/03/15/DOM操作/","link":"","permalink":"rychou.github.io/2019/03/15/DOM操作/","excerpt":"","text":"节点的关系1234567891011&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;ul id=\"test\"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 如上结构，有如下关系： 123456789let nodes = document.getElementsByTagName('li')console.log(nodes) // li 组成的类数组结构console.log(nodes[0].parentNode) // ulconsole.log(nodes[0].parentNode.firstChild.textContent) // 1console.log(nodes[0].parentNode.lastChild.textContent) // 4console.log(nodes[0].parentNode.firstChild.nextSibling.textContent) // 2console.log(nodes[0].parentNode.firstChild.nextSibling.previousSibling.textContent) // 2console.log(nodes[0].parentNode.firstChild.nextSibling.nextSibling.textContent) // 3console.log(nodes[0].parentNode.firstChild.nextSibling.nextSibling.nextSibling.textContent) // 4 操作节点1. 插入节点 方法一： sourceElement.appendChild(targetElement) 用于向sourceElement的childNodes列表结尾添加节点，返回添加的节点。如果添加的targetElement已经存在于childNodes中，则结果就是把原来的位置移动到新的位置（末尾） 方法二：sourceElement.insertBefore(targetElement, referenceElement) 用于向childNodes中指定元素之前插入元素。若第二个参数为null，则结果与方法一相同（插入到末尾）。 2. 替换节点sourceElement.replaceChild(targetElement, replacedElement)，用于替换节点。当替换一个元素时，replacedElement所有的关系指针会被targetElement复制，也就是被取代了位置。此时replacedElement依然在文档（document）中，只是没有了自己的位置。 3. 移除节点sourceElement.removeChild(removedChild)，接受的参数为要从childNodes中移除的元素。与replaceChild一样，元素移除后，依然在文档中，只是没有了自己的位置。 4. 克隆节点cloneNode()，御用克隆一个节点，它接受一个布尔值参数 参数为true，执行深复制，复制节点和其整个节点树。 参数为false，执行浅复制，只复制节点本身。复制后的节点归文档所有，但并没有为其指定父节点。可以称为‘孤儿’，除非用上面1、2提到的方法将其添加到文档中。 DOM扩展——选择符APIquerySelector()其接受一个CSS选择符作为参数，返回匹配的第一个元素，如果没有匹配则返回null。 123let body = document.querySelector(\"body\");let myDic = document.querySelector(\"#myDiv\"); querySelectorAll()与querySelector()类似，不同的是该方法返回的是符合匹配原则的NodeList实例。","categories":[],"tags":[{"name":"DOM","slug":"DOM","permalink":"rychou.github.io/tags/DOM/"}]},{"title":"春招面试","slug":"阿里零售通部门一面","date":"2019-03-14T14:05:29.000Z","updated":"2019-03-21T10:32:19.682Z","comments":true,"path":"2019/03/14/阿里零售通部门一面/","link":"","permalink":"rychou.github.io/2019/03/14/阿里零售通部门一面/","excerpt":"","text":"除了阿里一面记录比较详细，其他主要记录在面试过程中不会的问题 阿里零售通一面 讲讲最近项目经历 http请求过程 http多路复用是从哪个版本开始的 http 304 404 500 状态码表示的含义 讲讲浏览器缓存 看你github上的star还挺多的，介绍一下吧。 小程序和Web开发的区别 你有上线的小程序嘛，介绍一下。 你如何实现“在书云”扫码录入图书的，接口是自己写的吗？如何绕过豆瓣接口对小程序的请求限制？除了目前的方案有没有更好的方案？ 对ES6有了解吧？讲讲let和const，遍历数组有几种方式 讲讲对Redux的理解 开放题：1. 如果让你做一个可以供学生查询成绩的应用（成绩已经录入数据库），你打算怎么做。2. SQL查询 3. 未来前端规划 二面 10万个点，如何渲染到地图，前端可视化基础 react 生命周期 react-router 不用hash 实现单页应用中改变路由页面不刷新 nodejs 意见与建议 定期系统复习知识 笔试 二面结束后两个小时后面试官就找我笔试了，给的时间是1个小时，我40分钟左右就都做完了，后来一直纠结在第四题。后来面试官给我15分钟优化，我也纠结在第四题。。。最后也没优化到。。。。有点虚。 题目1：请为 Common 类编写一个 getType 方法，能够识别出不同的数据类型，请用原生 js（ES6） 实现。123456789101112131415161718192021222324252627282930const A = [1, 2];const B = \"String\";const C = /[\\w]/g;const D = new Date();const E = new Error(\"something wrong\");console.log(Common.getType(A)); // arrayconsole.log(Common.getType(B)); // stringconsole.log(Common.getType(C)); // regexpconsole.log(Common.getType(D)); // dateconsole.log(Common.getType(E)); // error// 以下为回答class Common&#123; getType(x)&#123; const temp = Object.prototype.toString.call(x).split(''); temp.pop(); return temp.slice(8).join('').toLowerCase(); &#125; &#125;// 优化后的答案class Common&#123; getType(x)&#123; /* * 笔试时不知道string也能slice,其次对于slice的方法掌握不透彻，不知道slice(8,-1)的-1指向倒数第二个元素 */ return Object.prototype.toString.call(x).slice(8,-1).toLowerCase(); &#125;&#125; 题目2：在文档流中存在一个元素 id 为 test， 除去点击 test 元素，点击文档流中的任何一个元素让 test 元素隐藏，请用原生 js（ES5） 实现12345window.addEventListener('click',function(e)&#123; if(e.target.id !== 'test')&#123; document.getElementById('test').style.visibility = 'hidden';// display:none 会引起reflow &#125;&#125;,false) 题目3:如图可见区域container的总宽度为100%，内部有三个 div，column1宽度是400px，column2和 column3宽度相同。请补充CSS3来实现基于以下dom结构的布局。已知的Dom结构： 12345&lt;div class=\"container\"&gt; &lt;div class=\"column\"&gt;column1&lt;/div&gt; &lt;div class=\"column\"&gt;column2&lt;/div&gt; &lt;div class=\"column\"&gt;column3&lt;/div&gt;&lt;/div&gt; 回答： 123456789101112.container&#123; display: flex; &#125;.column:nth-child(1)&#123; width: 400px&#125;.column&#123; background: red;&#125;.column:nth-child(2), .column:last-child&#123; flex-grow: 1;&#125; 题目4: 给 Array 对象增加一个原型方法，用于删除数组条目中重复的条目(可能有多个)，返回值是一个包含被删除的重复条目的新数组。123456789101112131415function removeMultiple()&#123; let arr = this; let temp = []; let result = []; for(let i=0; i&lt;arr.length;i++)&#123; if(!(arr[i] in temp))&#123; temp.push(arr[i]) &#125;else&#123; result.push(arr[i]) &#125; &#125; return result;&#125;Array.prototype.removeMultiple = removeMultiple 腾讯IEG一面 渲染树渲染效率优化 XSS与CSRF 5层/7层协议栈 React性能优化相关 Js new 与 Java new的区别 如何实现两台机器两个浏览器，一个在页面画画，另一个页面同步显示 意见与建议 后端知识也要学习 理论不错，需要配合实践 腾讯PCG一面 如何实现继承 Websocket 快排 XSS与CSRF的区别 301和302状态码 意见与建议 基础算法知识 总结能力待提高","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"rychou.github.io/tags/面试/"}]},{"title":"珠海&广州旅行","slug":"珠海行","date":"2018-12-19T13:48:29.000Z","updated":"2019-01-26T16:11:27.865Z","comments":true,"path":"2018/12/19/珠海行/","link":"","permalink":"rychou.github.io/2018/12/19/珠海行/","excerpt":"","text":"一、第一次坐飞机这是我人生第一次坐飞机呀，内心有很多期待。这次坐飞机发生了一件非常沙雕的事。 机场不是在杭州而是在上海浦东机场，机票是买的金鹏航空早上6:30的特价机票，所以需要提前一天晚上出发去上海浦东机场。我是 27 号晚上从杭州去上海，需要在机场过夜。到上海已经 9 点了，去机场的二号线末班是10:30的，所以到了人民广场也没时间去吃炸鸡了。直接搭乘地铁去机场了。 关键来了，因为当时没吃晚饭，肚子很饿，穷学生又怕机场的吃的很贵，所以打算在机场前一站下车去找吃的！！！结果一下车发现，这。。。。荒郊野岭哪里有吃的，然后就在地图上找周围的吃的便利店等等，结果在那附近走了近一个小时，放弃了。肚子饿的不行，只能去机场了，又走了一个小时到达机场，腿都要断了。那天我走了 2w 多步。到了机场发现，机场的全家并不贵，哭死了呜呜呜。 然后就是去航站楼了，结果航站楼也走错了，我的是T2，我走到T1去了。 最后拿了登机牌在地上睡了一会，差点睡过头了（真的是差一点），那天是真是诸事不顺。 不过还好顺利登机啦！ 二、珠海 纵使身心疲惫不堪，只要是要去见你，再累我内心都是很开心的。 从上海到珠海花了 2 个半小时左右，到了珠海已经是早上 10 点了，一宿没睡的我实在是已经困的不行，但是想着要去见自家宝宝，便变得精神起来。二话不说，订了最近一班的到拱北的机场大巴，上车！ 这时候的你也准备从学校出发来珠海了，原先订好了从顺安车站-&gt;珠海的车票，在当天早上被告知班车取消了，给我们的珠海之行增添了一个小插曲。不过你也迅速找到了解决办法，那就是搭公车到珠海。也真是很方便只需要换乘一次，就可以搭公车到珠海来了。 931 路 异地恋最幸福的时刻，莫过于双方见面那一瞬间的对视，之前的分别之苦在这一刻都显地微不足道了。 我在不断驶入驶出公车总站的公车群中寻找着那辆931路公车，来了一辆931路公车，抬头望去，伸长了脖子(会是你坐的那辆吗？)，目光迅速扫视着车窗内的人群，寻找那个熟悉得不能再熟悉的身影。我没找到，这不是你乘坐的那辆。一辆、两辆、三辆。。。终于在收到你即将进站的消息时，目光锁定了那辆931路公车。这时天下起了毛毛雨，在我撑开伞的时候，看到了那个熟悉的身影，在车窗内的你冲我笑了一下。 在接到你后，本想抱你来着，怕尴尬的你冲我耳语着：“快走快走！” 摧毁了我对见面时的想象。这里有点小失落，毕竟对这一刻有着特别的期待。不过也习惯辽，啥时候能治愈你的尴尬癌呢。 海泉湾 去海泉湾还是你在双十一之前偶然看到海泉湾的打折票，599 元两个人一天一夜，包括了无限次温泉、游乐场、运动俱乐部等。 到海泉湾度假村已经是下午两点多了，办理了酒店的入住，这里的房间真的很不错。在房间简单休息了一下之后就准备去泡温泉了，从酒店到温泉的路程也很近，步行大概十分钟就到了。 ✔ 第一次一起泡温泉拿着酒店的房卡，可以无限次去泡温泉，我们当天泡了两次温泉，下午去了一次，晚上在运动俱乐部玩完后还去了一次。温泉真的超舒服哒。👙 晚上去看了海泉湾的梦幻剧场，表演也很棒，还有几个表演的是外国人来的。 ✔ 第一次一起玩射箭看完剧场表演之后去了运动俱乐部，玩了射箭和台球。射箭也是第一次玩，你最后一支箭居然射 🎡 中了 10 环，哈哈哈哈哈好厉害！我也表演了一波台球跳球入洞嘻嘻！ ✔ 第一次一起玩跳楼机第二天也就是11月30日，是我滴生日。今年的生日，你送了我小米手环3 NFC版，虽然已经提前送我了，没惊喜，但是也是我很喜欢的礼物，谢谢宝宝啦！ 早上一起去吃了酒店的自助早餐，还挺不错哒，吃了很多烤培根肉。吃完就直接去游乐场玩了。 可能由于是淡季，游乐场开放的设施不是很多，玩了镜面迷宫、跳楼机、碰碰车、海盗船。跳楼机真的是好恐怖啊，现在想想都有点手心冒汗，以后都不怎么敢去玩那些项目了。特别是有些游乐场的工作人员还调皮（虽然这里的工作人员不调皮），故意跟你说安全带没系好，然后突然BOOM。。。 从海泉湾玩完之后来到了燊记,在小红书看到这里的海鲜肠粉很诱人，就想着一起过来吃。但是到的时候肠粉还没开始卖呢，有点小遗憾，不过宝宝超爱吃那里的湿炒牛河。 吃完之后就去车站准备坐大巴去广州了，珠海-&gt;广州 三、广州到了广州当晚，我们也都有点累，就没有出去玩，在酒店待了一晚。 第一天第二天出门去吃了广九餐室，忘记菜品名字了，点了鸡腿、猪扒包、巧克力奶茶，两个人吃的挺饱的。吃完之后一起去看了憨豆特工3,电影也还挺不错的，票价也很便宜。 晚上呢就去了上下九，人也是真的超级多，没怎么玩，就随便逛了逛，吃了以前一直想吃的陈记鱼皮，口感还不错，￥ 25 的价格偏贵了。还有那边买的猪脚姜你说不好吃，味道太重口了。 后来去买了一杯喜茶，不知道叫啥名字，但是口味是葡萄味的，里面的葡萄很好吃，是我喜欢的。之后就准备去吃海底捞了，走了好远，到了之后被告知已经要打烊了，不接客了真是气死，心情瞬间不好了。 肠胃炎 没事宝宝，有我在呢！ 这是这趟旅行唯一唯一不好的点了。在第二天晚上回到酒店已经 11 点多了吧，你因为我在公车的时候去帮你在后面抢座位，没去你身边陪着你，发了小脾气。 在点了外卖（烧烤 🍖）之后不久，你开始肚子不舒服，到厕所里面蹲了半个小时，真把我给担心坏了。当时也不是你的姨妈期，你也没有痛经过，应该是肠胃炎了。跟你说我出门去找找药店有没有药卖，在地图上找了附近所有的药房，跑了一家又一家，没有一家还在营业的药店。当时已经快 1 点了，附近的药房都已经关门了。微信这一头，你跟我说肚子还是痛，担心的不行，跑回酒店，给你烧了热水喝了也不见好转。 这时烧烤外卖也到了，但是根本就没心情吃，带你起身去医院。 出门叫了辆的士，叫司机去离这最近的医院，去了最近的一家中医院。医院这时候只有急诊还开着，在挂号的地方，没有足够的现金，但工作人员还是好心的让我给她一块钱挂了急诊。 医生的初步诊断为急性肠胃炎，让宝宝打了一针屁股针和挂吊瓶，大概有 5 袋吊瓶吧。喝了几杯温水之后，你感觉似乎好点了。终于也在这时候，我的心终于踏实了一点了。 在挂吊瓶到一半的时候，救护车送来了一位急诊患者，应该是心梗吧，家属在急诊室外很丧很丧的哭。希望人没事吧！🙏🙏🙏 护士们都去帮忙抢救了，最后一瓶吊瓶还是我自己换的，挂完吊瓶之后跟门诊的人打了声招呼就回去了。 回来已经凌晨三点多了，烧烤也已经冷了。在你睡着之后，我吃了几口已经冷了的烧烤，回想了当天发生的所有，要是你的身体出了什么事情，我真的是担心的不得了。那时的感觉就像我高中有一次带我妹妹去逛超市，在付钱的时候一转眼，妹妹不见了，那感觉就是整个人都懵了，心里慌慌的、空空的。那时候我紧张的不得了，到处叫妹妹的名字，想办法找到妹妹。结果最后发现，她居然在旁边看别人玩游戏机。就是有一种失而复得的感觉吧！ LAST DAY 做大做强！ 最后一天，也就是你生病的第二天，起来的时候你已经好很多了，我也放心多了。下午去吃了沙县和东北饺子，还一起在酒店附近的一家电影院看了无名之辈。 晚上送你坐车回中山之后，我也赶着去火车站坐车了。 到这里，我们的珠海&amp;广州行也就结束了，记录的文笔很糟糕，但这也是我最真实的记忆。旅行过程中有开心的时候，也有担心的时候，从中也收获到很多，以后出行的时候得带你吃清淡一点的了，养生旅行 ✔ 四、美食emmmm….由于宝宝没上传美食的照片，这里就不贴照片了 打脸了打脸了，在宝宝的朋友圈翻到了美食照片嘻嘻。 这两天吃了很多好吃的","categories":[],"tags":[{"name":"珠海","slug":"珠海","permalink":"rychou.github.io/tags/珠海/"},{"name":"广州","slug":"广州","permalink":"rychou.github.io/tags/广州/"}]},{"title":"漫谈微信小程序","slug":"漫谈小程序","date":"2018-12-09T06:25:08.000Z","updated":"2018-12-10T02:37:30.444Z","comments":true,"path":"2018/12/09/漫谈小程序/","link":"","permalink":"rychou.github.io/2018/12/09/漫谈小程序/","excerpt":"","text":"一、微信小程序与传统 App 的对比优点：1. 开发成本成本与收益永远是商家最关注的两个核心问题。一般传统 APP 的开发费用普遍都是 5 万以上左右，对于部分大型企业客户的收费基本是在 10 万以上。目前，微信端小程序收费不高，基本可在万元内。事实上，两者后台调用的数据库并无区别，只是传统 APP 的前端更花一些功夫罢了。传统 App 分有 Android 和 IOS 开发，而小程序开发更加接近于 Web 开发。总体而言，传统 APP 的开发成本要高出微信小程序很多。 2. 推广成本相信大家也见过，有一类的兼职就是 App 推广，推荐一个人下载安装 App 就能得到 6-10 元的回报。而小程序并不需要这样，即点即用。主要的推广模式是靠分享推广，所以你肯定见过这样的套路：在玩某些小程序游戏的时候，如果你死了，小程序会提示你分享到一个群里就可以复活，这样由用户自发的推广，可以说是 0 成本，但是又是高收益的。 3. 安装方式传统 APP 应用需要用户自行下载安装，微信小程序则只需要用户简单扫描一下微信二维码或自生（开发出来的）即可轻松实用，对于大量具有线下经营实体的商家而言，无疑更为合适，对于用户来说，也更简单方便。 4. 空间占用传统 APP 安装到手机之后，或多或少会占用一定的手机空间。同时，商家为了强化自身的 APP 应用价值，开始罔顾用户需求，不断给 APP 增添各种附加功能，从而导致 APP 的体积和占用空间不断增大。诸君可曾见，哪个 APP 是越升级，体积越小？占用空间越小的？ 那小程序是否会占用手机空间呢？答案是肯定的。 小程序所占用的手机存储空间，主要有以下两个部分： 首次加载小程序时，微信从服务器上下载的小程序本体。 小程序在运行过程中，存放至本地的数据。 首先是小程序本地的大小，做过小程序开发的应该都知道，微信对小程序的体积做了限制，只有 2 MB 以内的小程序，才能提交到微信审核。也就是说，如果你无法提交代码大小超过 2MB 的小程序。 其次是小程序存放在本地的数据，这个微信限制在 10MB 以内。 一个小程序可占用存储空间的上限，大约是 12 MB。 5. 卸载残留由于传统 APP 都需要用户下载安装，基于利益角度考量，用户在卸载的时候，传统 APP 依然或多或少地有部分内容残留在用户手机里面。 小程序删除时，微信会帮你把本地的小程序本体和本地数据删除 6. 升级维护传统 App 升级需要用户自行下载，安装进行升级。而小程序升级省去了用户操作，开发者把要升级的版本上传到微信后台，微信后台会帮你完成所有的升级工作。 目前市场上主流的移动端系统为 Android、Ios，这意味着，App 开发商不得不考虑跨平台性，必须得开发两端的 APP。而小程序是运行在微信之上，微信本身已经处理好的跨平台性让开发者不需要考虑跨平台的问题。 缺点：1. 不适用于复杂应用2MB 的大小限制注定了小程序开发太复杂的应用，你不可能在小程序上面开发一款即时通讯应用。当然你开发是可以开发，只是过不了微信的审核罢了。 那有什么应用是适合用小程序开发的呢？ 查询工具这类交互性要求不强的应用是最适合用小程序开发的。 这类应用本身只提供一个核心的功能，如果用传统 APP 开发，那就显地有点杀鸡用牛刀了。微信小程序就很适合这类应用。举个很形象了例子吧！超级课程表这 APP 大家都用过吧，它最核心的功能就是提供全国大学的课程表查询。它还开发了很多其他我没用过的功能。绝大部分的大学生，都是只需要他这个查询课程表的功能，所以如果用小程序开发这个应用，首先解决的跨平台的问题、其次还解决了空间占用的问题（超级课程表在我手机中占用的空间为 136MB）、还有就是用户即点即用，不需要下载安装。 2. 入口少目前小程序的入口主要有两种，一是分享、二是用户搜索。这里要说的入口少指的是第二点，用户搜索的入口。 什么意思呢？大家如果想要安装一款 APP 首先要去哪里？应用商店。那小程序呢？你得打开微信，搜索你想要的相关关键字。这样的缺点是，用户比较难找到一款优质的小程序，因为并没有一个好小程序应用商店对小程序进行分类排名和评分来保障应用的质量。一个好的应用商店对应用的质量提升是很有保障的，爱奇艺很多人都用过吧，是否很烦它那烦人的广告呢？其实如果你从谷歌应用商店下载的爱奇艺，是没有广告的，因为有广告的 APP 根本过不了谷歌应用商店的审核。 二、微信小程序的开发方式目前小程序开发的方式前端总的来说，目前有两种方式开发小程序，一是用原生小程序的语法来开发、二是用第三方框架。 微信为小程序开发自创了一套标签语言，如果有做过小程序开发和熟悉 Vue 开发的应该知道，原生小程序的开发与 Vue 的开发有很多相似的地方。 因此，微信官方自己推出了一套小程序开发框架Wepy（名字听起来怪怪的），这个框架就让小程序开发更接近于 Vue，官方介绍说是类 Vue 开发风格。 后来美团也整了一套开发框架mpvue，这个就厉害了，直接用 vue 来开发小程序，并且官方号称支持一套代码、多端公用（写一套代码，可以编译成 H5、微信小程序、支付宝小程序）。其实这个多端公用很鸡肋。 怎么一直在说 Vue 呢？有没有 React 呢？有的。 Taro：多端统一开发框架，支持用 React 的开发方式编写一次代码，生成能运行在微信小程序、H5、React Native 等的应用。 后端这也有两种方式，一是和常规后端开发一样的，提供一套接口给前端使用、二是小程序云开发 这里重点讲讲小程序云开发，这是小程序刚出不久的功能，目的是弱化后端概念。开发者无需搭建服务器、使用微信小程序平台提供的 API 进行核心业务开发，即可实现快速上线和迭代，同时这一能力，同开发者已经使用的云服务相互兼容，并不互斥。 三、我怎么开发小程序我的开发方式是这样的，如果是个人开发项目我会选择mpvue+云开发。如果是团队开发项目则mpvue+后端。 我不选原生小程序开发是因为这需要一定的学习成本、其次我不想把自己限制在微信小程序开发中。选择mpvue你不仅可以做小程序开发还可以做Web开发 不选taro的原因是它的成熟度不及mpvue，现在选taro需要花时间去踩坑。","categories":[],"tags":[{"name":"小程序","slug":"小程序","permalink":"rychou.github.io/tags/小程序/"}]},{"title":"面试题收集","slug":"面试题收集","date":"2018-11-24T16:05:29.000Z","updated":"2019-03-16T15:30:32.512Z","comments":true,"path":"2018/11/25/面试题收集/","link":"","permalink":"rychou.github.io/2018/11/25/面试题收集/","excerpt":"","text":"1. 实现一个函数，判断输入是不是回文字符串. 回文字符串：顺着读和反着读是一样的。如：noon 123456789function run(input) &#123; if (typeof input !== 'string') return false return ( input .split('') .reverse() .join('') === input )&#125; split拆分字符串，返回数组。 reverse将字符串倒序。 join 与split作用相反，将数组转换成字符串。 2. 实现已知或者未知宽度的垂直水平居中。1234567891011121314151617181920212223242526272829303132333435363738394041/* 方法一 */.wraper &#123; position: relative;&#125;.wraper .box &#123; position: absolute; top: 50%; left: 50%; width: 100px; height: 100px; margin: -50px 0 0 -50px;&#125;/* 方法二 */.wraper &#123; position: relative;&#125;.wraper .box &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);&#125;/* 方法三 */.wraper.box &#123; display: flex; justify-content: center; align-items: center; height: 100px;&#125;/* 方法四 */.wraper &#123; display: table;&#125;.wraper .box &#123; display: table-cell; vertical-align: middle;&#125; 3. 请简单实现双向数据绑定 mvvm1&lt;input id=\"input\" /&gt; 1234567891011const data = &#123;&#125;const input = document.getElementById('input')Object.defineProperty(data, 'text', &#123; set(value) &#123; input.value = value this.value = value &#125;&#125;)input.onChange = function(e) &#123; data.text = e.target.value&#125; 参考：Object.defineProperty 4. isPrime-判断质数12345678function isPrime(num) &#123; for (let i = 0; i &lt; num; i++) &#123; if (num % i === 0) &#123; return false &#125; &#125; return true&#125; 5. factorial-求阶乘1234567891011function factorial(num) &#123; var count = 1 for (let i = num; i &gt; 0; i--) &#123; count *= i &#125; return count&#125;function factorial2(num)&#123; return num === 1 ? 1 : factorial2(num-1) * num&#125; 6. fib - 返回斐波那契数 斐波那契数: F0=0, F1=1, Fn=Fn-1+Fn-2 最简单的写法，但是效率低，会有很多重复运算。 123function fib(n) &#123; return n === 0 || n === 1 ? n : fib(n - 1) + fib(n - 2)&#125; 高效写法： 1.把计算过的结果保存缓存起来，避免重复计算 123456789let fib = (function() &#123; let memory = [] return function(n) &#123; if (memory[n]) &#123; return memory[n] &#125; return memory[n] = n === 0 || n === 1 ? n : fib(n - 1) + fib(n - 2) &#125;&#125;)() 2.尾调用优化 1234567891011function Fibonacci2(n, ac1 = 1, ac2 = 1) &#123; if (n &lt;= 1) &#123; return ac2 &#125; return Fibonacci2(n - 1, ac2, ac1 + ac2)&#125;Fibonacci2(100) // 573147844013817200000Fibonacci2(1000) // 7.0330367711422765e+208Fibonacci2(10000) // Infinity 7. filter - 实现filter函数1234567891011function filter(arr, fn) &#123; var array = [] for (var i = 0; i &lt; arr.length; i++) &#123; if (fn(arr[i])) &#123; array.push(arr[i]) &#125; &#125; return array&#125;filter([1, 2, 3, 4, 6, 10, 17], n =&gt; n &gt; 0 &amp;&amp; isPrime(n)) //[1,2,3,17] 123456789101112131415function $initHighlight(block, cls) &#123; try &#123; if (cls.search(/\\bno\\-highlight\\b/) != -1) return process(block, true, 0x0F) + ` class=\"$&#123;cls&#125;\"`; &#125; catch (e) &#123; /* handle exception */ &#125; for (var i = 0 / 2; i &lt; classes.length; i++) &#123; if (checkCondition(classes[i]) === undefined) console.log('undefined'); &#125;&#125;export $initHighlight; 8. 代码回收规则 全局变量不会被回收。 局部变量会被回收，也就是函数一旦运行完以后，函数内部的东西都会被销毁。 只要被另外一个作用域所引用就不会被回收 9. 杨辉三角 Fm n = Fm-1 n + Fm-1 n-1 12345678910111213141516function print(n)&#123; for(let i = 1; i&lt;=n; i++)&#123; let arr = []; for(let j = 1; j&lt;=i; j++)&#123; arr.push(getNum(i,j)) &#125; console.log(arr.join(' ')) &#125;&#125;function getNum(m, n)&#123; if( m === 1 || n === 1 || m === n)&#123; // 第一行只有一个数——1，其他行第一个元素和最后一个元素为1 return 1; &#125; return getNum(m-1, n) + getNum(m-1, n-1)&#125; 10. new命令执行过程 参考：new命令原理 创建一个空对象，作为将要返回的对象实例。 将这个空对象的原型，指向构造函数的prototype属性。 将这个空对象赋值给函数内部的this关键字。 开始执行构造函数内部的代码。 如果构造函数内部return了一个对象，则在new时会返回指定的对象。如果return不是一个对象，则与正常的new一样。","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"rychou.github.io/tags/面试/"}]},{"title":"英语学习专题","slug":"英语学习专题","date":"2018-11-23T13:48:29.000Z","updated":"2018-12-15T11:18:17.929Z","comments":true,"path":"2018/11/23/英语学习专题/","link":"","permalink":"rychou.github.io/2018/11/23/英语学习专题/","excerpt":"","text":"一、短语call it a day: 一天快要结束了。可以在下班的时候说。 call it a night: 一晚快要结束了。如果你在某个地方浪到很晚可以这样说。 hunkey-dory: hunky 意思是肌肉发达的，但是这个短语的意思与fine类似。 二、写作1. There is an old Chinese proverb(谚语) which states(声明，三单) &#39;A journey of a thousand miles starts with a single step&#39;. 2. It goes without saying that ... 3. Amount various kinds of ... 4. With the advance of science and technology 5. In this age of information and communication, ... plays an extremely important role. 6. Recently it has become a common phenomenon","categories":[],"tags":[{"name":"English","slug":"English","permalink":"rychou.github.io/tags/English/"}]},{"title":"Js学习笔记之行为委托","slug":"Js学习笔记之行为委托","date":"2018-11-23T06:23:29.000Z","updated":"2018-11-23T04:38:36.347Z","comments":true,"path":"2018/11/23/Js学习笔记之行为委托/","link":"","permalink":"rychou.github.io/2018/11/23/Js学习笔记之行为委托/","excerpt":"什么是行为委托行为委托是一种不同于类的设计模式","text":"什么是行为委托行为委托是一种不同于类的设计模式 下面这段是类的设计模式 1234567891011121314151617class Task &#123; id; /** 构造函数 Task()*/ Task(ID) &#123; id = ID; &#125; outputTask() &#123; output( id ); &#125;&#125;class XYZ inherits Task &#123; label; /** 构造函数 XYZ()*/ XYZ(ID,Label) &#123; super( ID ); label = Label; &#125; outputTask() &#123; super(); output( label ); &#125;&#125;class ABC inherits Task &#123; // ...&#125; 123456789101112131415161718192021Task = &#123; setID: function(ID) &#123; this.id = ID &#125;, outputID: function() &#123; console.log(this.id) &#125;&#125;/** 让 XYZ 委托 Task*/XYZ = Object.create(Task)XYZ.prepareTask = function(ID, Label) &#123; this.setID(ID) this.label = Label&#125;XYZ.outputTaskDetails = function() &#123; this.outputID() console.log(this.label)&#125;// ABC = Object.create( Task );// ABC ... = ... 在这段代码中， Task 和 XYZ 并不是类（或者函数），它们是对象。 XYZ 通过 Object.create(..) 创建，它的 [[Prototype]] 委托了 Task 对象 从代码中可以看出，行为委托的设计模式与类的“父子对象”不同，使用的是一种“兄弟对象” 相比于类的设计模式： 在上面的代码中， id 和 label 数据成员都是直接存储在 XYZ 上（而不是 Task ）。通常来说，在 [[Prototype]] 委托中最好把状态保存在委托者（ XYZ 、 ABC ）而不是委托目标（ Task ）上 在类设计模式中，我们故意让父类（ Task ）和子类（ XYZ ）中都有 outputTask 方法，这样就可以利用重写（多态）的优势。在委托行为中则恰好相反：我们会尽量避免在[[Prototype]] 链的不同级别中使用相同的命名，否则就需要使用笨拙并且脆弱的语法来消除引用歧义. 这个设计模式要求尽量少使用容易被重写的通用方法名，提倡使用更有描述性的方法名，尤其是要写清相应对象行为的类型。这样做实际上可以创建出更容易理解和维护的代码，因为方法名（不仅在定义的位置，而是贯穿整个代码）更加清晰 this.setID(ID) ； XYZ 中的方法首先会寻找 XYZ 自身是否有 setID(..) ，但是 XYZ 中并没有这个方法名，因此会通过 [[Prototype]] 委托关联到 Task 继续寻找，这时就可以找到setID(..) 方法。此外，由于调用位置触发了 this 的隐式绑定规则（参见第 2 章），因此虽然 setID(..) 方法在 Task 中，运行时 this 仍然会绑定到 XYZ ，这正是我们想要的。在之后的代码中我们还会看到 this.outputID() ，原理相同。 换句话说，我们和 XYZ 进行交互时可以使用 Task 中的通用方法，因为 XYZ 委托了 Task 委托行为意味着某些对象（ XYZ ）在找不到属性或者方法引用时会把这个请求委托给另一个对象（ Task ）。 这是一种极其强大的设计模式，和父类、子类、继承、多态等概念完全不同。在你的脑海中对象并不是按照父类到子类的关系垂直组织的，而是通过任意方向的委托关联并排组织的。 本文参考自： 书籍：P164，你不知道的 Javascript 之闭包——上卷。 附：你不知道的 Javascript 系列电子书网盘链接， 密码：i8jf","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"rychou.github.io/tags/Javascript/"}]},{"title":"简谈文件下载的三种方式","slug":"简谈文件下载的三种方式","date":"2018-11-05T06:23:29.000Z","updated":"2018-11-17T12:36:09.406Z","comments":true,"path":"2018/11/05/简谈文件下载的三种方式/","link":"","permalink":"rychou.github.io/2018/11/05/简谈文件下载的三种方式/","excerpt":"","text":"一、前言本文章将以excel报表下载为例，给大家介绍三种文件下载的方式。 二、正文1. 通过服务器文件地址下载这是最常见的文件下载方式，大多数网站的音频、视频、种子文件等文件的下载方式都是通过这种方式实现的。 这种方式具体的实现方式是这样的： 前端请求获取excel报表的下载地址 后端根据前端的请求，查询数据库并把查询结果保存到服务器的一个excel文件中 后端把这个excel文件地址返回给前端 前端将此excel文件地址赋值给一个&lt;a href=&quot;http://test.com/excel.xls&quot;/&gt;,并点击此&lt;a/&gt;标签，利用浏览器的默认行为下载此文件。 优点：实现方式简单，通用。缺点：需要把文件保存到服务器，会占用服务器资源。这个缺点也有解决方式：给保存的文件设定一个时效性，过了这个时效，服务器就会删除这个文件。 2. 通过二进制数据流的方式下载这种方式是我目前采用的方式，用于处理报表下载。 这种方法的具体实现流程如下： 前端请求获取excel报表的二进制数据流 后端根据前端请求，查询数据库并把查询结果转成二进制数据流。注意：这里并不生成一个文件保存在服务器 后端把二进制数据流返回给前端 前端把二进制数据流转成URL对象并赋值给&lt;a/&gt;标签 点击&lt;a/&gt;标签实现下载 我用的是axios网络请求库 代码示例： 123456789101112131415161718axios(&#123; url: '/monitors/export', method: 'GET', responseType: 'blob' //指定返回数据格式&#125;).then(res =&gt; &#123; // 将二进制数据流转成URL对象 const url = window.URL.createObjectURL( new Blob([res.data], &#123; type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;charset=utf-8' &#125;) ) const link = document.createElement('a') link.href = url link.setAttribute('download', '车辆监控列表.xls') // 需要指定文件格式。 document.body.appendChild(link) link.click() //点击事件&#125;) 优点：不需要服务器生成文件，并保存到服务器中，可以有效减少服务器资源占用。缺点：这种方式可能并不那么通用，也可能有一定的兼容性问题。 3. 前端下载这种方式是我测试过，确实可行的一种方法，它的具体实现原理是这样的，前端通过类似export-from-json的库，把JSON格式的报表数据，导出到excel文件中。 优点：不需要为下载单独发起一次网络请求，直接把保存在前端的请求的报表数据，导出到excel文件即可。缺点：对于数据量不大的文件，这种方式是可行的。但是对于数据量很大，像几千几万条数据的话，性能缓慢是它最大的弊端。","categories":[],"tags":[{"name":"文件下载","slug":"文件下载","permalink":"rychou.github.io/tags/文件下载/"}]},{"title":"mpvue中小程序云开发总结","slug":"mpvue中小程序云开发总结","date":"2018-10-10T06:23:29.000Z","updated":"2018-11-17T12:35:14.866Z","comments":true,"path":"2018/10/10/mpvue中小程序云开发总结/","link":"","permalink":"rychou.github.io/2018/10/10/mpvue中小程序云开发总结/","excerpt":"一、前言这两天在用踩坑了一下小程序云开发，用 mpvue、vant 组件库、wux 组件库、小程序云开发开发了一款小程序。算是初试云开发了，所以总结一下使用上的注意事项。","text":"一、前言这两天在用踩坑了一下小程序云开发，用 mpvue、vant 组件库、wux 组件库、小程序云开发开发了一款小程序。算是初试云开发了，所以总结一下使用上的注意事项。 二、开启云开发功能 确保你的微信开发工具是最新版的小程序云开发文档 1. 注册一个小程序账号小程序云开发必须有小程序 AppId 才能使用，所以首先应先注册一个小程序账号（如果已有请忽略）。记录下设置-&gt;开发设置中的小程序AppId 2. 用mpvue初始化一个项目 参考：mpvue 官方文档 1234567891011# 全局安装 vue-cli$ npm install --global vue-cli# 创建一个基于 mpvue-quickstart 模板的新项目$ vue init mpvue/mpvue-quickstart my-project# 安装依赖$ cd my-project$ npm install# 启动构建$ npm run dev 2. 在微信开发者工具中新建项目新建项目选择的目录为dist目录，然后填写刚刚注册的小程序的AppId。 打开项目之后，可以发现开发者工具中多了个云开发的按钮。点击之后，安装提示配置，就可以了。微信默认免费提供开发者一个服务器进行云开发，对于小型程序来说是够用了。 三、正式使用云开发1. 开发前的配置首先在src/main.js文件添加以下语句。 123wx.cloud.init(&#123; traceUser: true&#125;) 必须要初始化才能使用云开发，traceUser决定是否在将用户访问记录到用户管理中，在控制台中可见。 2. 初试数据库云开发的数据库是一个JSON数据库，这里使用了查询数据的功能。 添加数据 首先得有数据，你可以在程序里进行插入数据（提交表单时使用）（参考云开发的文档），也可以手动的在云开发控制台中插入数据。 我直接在控制台插入数据好了。 在控制台的数据库中，点击添加集合-&gt;填入集合名称-&gt;在集合中点击添加纪录-&gt;添加所需的数据。这种插入数据的方式，是不带有用户态的(openId)，如果你的权限设置是管理员可读的话，那是没办法读取到信息的，因为没有 openId，没办法识别你的身份。 千万记住，要考虑你的集合数据的使用范围进行权限设置，比如我添加的是article文章，那这是公开的。那我就应该在权限设置中修改为所有用户可读、仅管理员可写，默认的是仅创建者及管理员可读写。 查询数据 12345678910mounted&#123; // env是你云开发的环境id。 const db = wx.cloud.database(&#123; env: 'meow-helper-1b5609' &#125;) this.db.collection('article').get() .then(res=&gt;&#123; console.log(res.data) // 可以进行数据初始化 &#125;) .cathc(console.error)&#125; 可以看到，使用方法很简单，当然你也可以使用回调的方式查询数据，具体参考云开发文档。 3. 云开发下的登录流程云开发大大简化了登录流程，因为每当有用户访问时，都会在云开发控制台留下该用户的openId。所以，我处理登录流程如下： 使用&lt;button&gt;&lt;/button&gt;组件获取用户授权 使用云函数从后端返回用户openId (待会会讲如何使用云函数) 如果同时有openId以及用户是否授权，那么就登录了 若用户授权了，那么你能在云开发控制台的用户管理中看到用户信息，否则只能看到一条记录以及openId 4.云函数的使用这里讲解如何通过云函数返回用户的openId 配置云函数根目录 在/static目录下创建目录funtions，然后在project.config.json文件下新增字段 123&#123; \"cloudfunctionRoot\": \"/static/functions/\"&#125; 注意：这可能在编译后不会生效，保险起见，应在npm run dev后检查dist/project.config.json文件，看看刚刚的字段是否添加成功，如果没有，请在dist/project.config.json中也添加上述字段。 新增云函数 新增云函数这一步必须得在微信开发者工具中进行。 打开开发者工具 在编辑器窗口下，右键/static/funtions，选择新建 Node 云函数 填写云函数名,如user，回车。 在弹出的窗口中，会询问你是否安装wx-server-sdk，点击确定（如果安装没有进行，可以自己手动在命令行中运行npm install） 完成以上步骤后就可以在index.js中编写云函数了。以下的云函数代码用于返回用户openId 123456789// 云函数入口文件const cloud = require('wx-server-sdk')cloud.init()// 云函数入口函数exports.main = async (event, context) =&gt; &#123; return event.userInfo&#125; 编写完成后，一定要记得右键云函数目录，选择上传并部署之后，才能使用云函数。 使用云函数 1234567891011121314151617// 调用云函数，返回用户openId，参数为云函数名称wx.cloud .callFunction(&#123; name: 'user' &#125;) .then(res =&gt; &#123; console.log(res) // 更新store中的openId this.$store.commit('updateOpenId', res.result) return this.WXP.getSetting() &#125;) .then(res =&gt; &#123; // 检验是否授权 const authUserInfo = res.authSetting['scope.userInfo'] if (authUserInfo) &#123; this.$store.commit('updateAuthUserInfo', authUserInfo) &#125; &#125;) .catch(err =&gt; console.error(err)) 5.存储的使用云开发的存储具有上传，下载，删除等功能，具体可以查看云开发文档。 它支持直接在&lt;image/&gt;,&lt;audio/&gt;等组件中直接使用云文件 id。接下来演示一下。 首先我们手动在云存储中上传一张图片，然后复制其fileId 在需要用到的地方引入即可： 1&lt;image src=\"cloud://meow-helper-1b5609.6d65-meow-helper-1b5609/img/13.png\"/&gt; 四、总结小程序云开发是属于最近刚出来的技术，目的是为了简化小程序的开发。特别适合于业务逻辑简单，功能不复杂的小程序。对于那些比如说电商平台等业务逻辑复杂的小程序，目前来说可能不适合了。 这个是我用云开发写的一个小程序，欢迎大家使用，提供建议。 猫叫助手 | 收录各种猫叫声，帮助与猫咪交流，分享一些养猫的小知识等。","categories":[],"tags":[{"name":"mpvue","slug":"mpvue","permalink":"rychou.github.io/tags/mpvue/"},{"name":"小程序","slug":"小程序","permalink":"rychou.github.io/tags/小程序/"},{"name":"云开发","slug":"云开发","permalink":"rychou.github.io/tags/云开发/"}]},{"title":"用Promise实现小程序接口链式调用","slug":"用Promise实现小程序接口链式调用","date":"2018-10-06T06:23:29.000Z","updated":"2018-11-17T12:34:12.129Z","comments":true,"path":"2018/10/06/用Promise实现小程序接口链式调用/","link":"","permalink":"rychou.github.io/2018/10/06/用Promise实现小程序接口链式调用/","excerpt":"","text":"一、前言 作者平时使用mpvue开发小程序，所以下面讲到的方法都是基于mpvue而言的，当然本质上原生小程序语法同样适用 大家都知道，小程序的接口都是采用回调的方式，这样如果代码逻辑复杂了，将会导致代码难以阅读。今天就通过ES6的Promise函数，来稍微改造一下小程序接口，让我们的代码实现链式调用，便于阅读。 二、核心代码在utils目录下新建文件WXP.js（WX Promise）,代码内容如下： 1234567891011121314151617181920// 代码核心，利用到了ES6的Promise函数function f(func, obj) &#123; return new Promise((resolve, reject) =&gt; &#123; func(&#123; ...obj, success: resolve, fail: reject &#125;) &#125;)&#125;// 改写所有wx接口var WX = &#123;&#125;for (let key in wx) &#123; WX[key] = obj =&gt; f(wx[key], obj)&#125;//将改写后的导出export default WX 代码原理很简单，主要就是在代码回调的地方，分别调用resolve和reject函数，分别对应着success和fail回调 三、在顶层main.js下全局配置WXP.js123456789101112// main.jsimport Vue from 'vue'import App from './App'import WXP from './utils/wxp'Vue.config.productionTip = falseApp.mpType = 'app'Vue.prototype.WXP = WXPconst app = new Vue(App)app.$mount() 这么做主要是全局配置之后，就不需要每个文件里面都导入WXP.js文件，便于使用。 四、使用改造前的回调方式： 12345678910111213141516wx.showLoading(&#123; title: '测试', success: function() &#123; wx.login(&#123; success: function(res) &#123; console.log(res.code) &#125;, fail: function(err) &#123; console.error(err) &#125; &#125;) &#125;, fail: function(err) &#123; console.error(err) &#125;&#125;) 改造后的链式调用方式 12345678this.WXP.showLoading(&#123; title: '测试' &#125;) .then(res =&gt; &#123; return this.WXP.login() &#125;) .then(res =&gt; &#123; console.log(res.code) &#125;) .catch(err =&gt; console.error(err)) 可以看出来，当回调的方式层次不深的时候还是便于阅读的，但是异步操作多了，层次就会多，这样代码就会变得难以阅读。而改造后的链式调用方式，不管你层次有多少，都是一条链一样，一步一步的，思路清晰，易于阅读。不得不说，Promise大法好哈哈哈哈哈哈哈哈哈 参考连接：小程序 API大白话讲解 Promise阮大佬的 Promise","categories":[],"tags":[{"name":"mpvue","slug":"mpvue","permalink":"rychou.github.io/tags/mpvue/"},{"name":"小程序","slug":"小程序","permalink":"rychou.github.io/tags/小程序/"},{"name":"Promise","slug":"Promise","permalink":"rychou.github.io/tags/Promise/"}]},{"title":"Linux操作系统下连接闪讯的方法（支持有线与无线）","slug":"Linux操作系统下连接闪讯的方法","date":"2018-10-05T06:23:29.000Z","updated":"2018-11-17T12:33:02.632Z","comments":true,"path":"2018/10/05/Linux操作系统下连接闪讯的方法/","link":"","permalink":"rychou.github.io/2018/10/05/Linux操作系统下连接闪讯的方法/","excerpt":"一、前言用过电信闪讯的同学都知道，闪讯没有开发 Linux 的客户端程序，所以这让很多玩 Linux 操作系统同时又是闪讯用户的同学很头疼，今天我就来介绍一下如何在 Linux 下连接闪讯网络，并且支持有线连接和无线连接。","text":"一、前言用过电信闪讯的同学都知道，闪讯没有开发 Linux 的客户端程序，所以这让很多玩 Linux 操作系统同时又是闪讯用户的同学很头疼，今天我就来介绍一下如何在 Linux 下连接闪讯网络，并且支持有线连接和无线连接。 本教材基于这个Github仓库shanxun_pppoe_linux_desktop 二、使用教程1. 克隆此仓库到本地shanxun_pppoe_linux_desktop 2. 安装 ppp 依赖1sudo apt-get install ppp 3. 修改或确认 makefile 文件的 TODO 项makefile 中的 TODO 项都有相关的注释，不同的系统可能有不同的配置，应先确认。 4. 安装和编译在仓库目录下执行： 123sudo chmod a+x INSTALLsudo ./INSTALL zhejiang_xiaoyuan_sxplugin#(其他地区请更换,地区列表在makefile内) 5. 连接闪讯网络由于闪讯网络有两种方式连接，有线和无线，方法略有不同。 首先在命令行执行ifconfig命令，记录下有线网卡和无线网卡名称，有线网卡名称是e开头的，无线网卡名称是w开头的，不同设备的名称不一样。 5.1 有线连接 直接使用以下命令连接有线： 1sudo connect_sx &lt;username&gt; &lt;password&gt; 参数分别是闪讯用户名和密码 12345678# 其后直接使用这个命令就可以了sudo connect_sx# 更改密码sudo connect_sx &lt;password&gt;# 断开连接sudo connect_sx stop 若连接不上，则尝试以下命令后再次尝试连接。 123sudo del default routesudo add default route &lt;有线网卡名称&gt;sudo connect_sx &lt;username&gt; &lt;password&gt; 5.2 无线连接 使用以下命令连接 1pppd noauth nodetach defaultroute usepeerdns maxfail 1 user &lt;your username&gt; password &lt;your password&gt; mtu 1492 mru 1492 plugin rp-pppoe.so nic-&lt;网卡名&gt; plugin zhejiang_xiaoyuan_sxplugin.so 需要配置的参数有用户名和密码，以及你的无线网卡名，此方法也可以用来连接有线，在网卡名填入对应的有线网卡名即可。 三、连接脚本针对以上连接方式，为了便于连接，我写了以下脚本，仅供参考。 12345678910111213141516171819202122232425262728#!/bin/bash# 是否连接有线ETH_STATE=`cat /sys/class/net/enp4s0/operstate`# 是否连接无线WLAN_STATE=`cat /sys/class/net/wlp1s0/operstate`# 连接的无线网络名称 其中wlp1s0是无线网卡名WLAN_NAME=`iwconfig wlp1s0 | grep ESSID | awk -F\\\" '&#123;print $2&#125;'`# 账号密码username=12345678911@DZKD.XYpassword=123456# 有线连接if [ \"up\" == $ETH_STATE ]then connect_sxfi# 无线连接if [ \"up\" == $WLAN_STATE ]then # 我所在环境能连闪讯的有三个无线WIFI if [ \"ChinaNet-shanxun\" == $WLAN_NAME ]||[ \"ChinaNet-tRmt\" == $WLAN_NAME ]||[ \"ChinaNet-tRmt-5G\" == $WLAN_NAME ] then pppd noauth nodetach defaultroute usepeerdns maxfail 1 user $username password $password mtu 1492 mru 1492 plugin rp-pppoe.so nic-wlp1s0 plugin zhejiang_xiaoyuan_sxplugin.so else echo \"is not shanxun\" fifi 在后台运行脚本： 1sudo nohup ./shanxun.sh &amp;","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"rychou.github.io/tags/Linux/"},{"name":"闪讯","slug":"闪讯","permalink":"rychou.github.io/tags/闪讯/"}]},{"title":"ES6数组去重和重复元素统计","slug":"ES6数组去重和重复元素统计","date":"2018-09-27T06:23:29.000Z","updated":"2018-11-17T12:32:27.360Z","comments":true,"path":"2018/09/27/ES6数组去重和重复元素统计/","link":"","permalink":"rychou.github.io/2018/09/27/ES6数组去重和重复元素统计/","excerpt":"","text":"一、去重这里利用到了ES6的Set结构不允许数据重复的特性 123let arr1 = [1, 1, 2, 3, 1, 2, 4, 2]//先将数组转化为Set数据类型，然后再转回数组类型let dedupeArr = Array.from(new Set(arr1)) 二、统计123456789let count = 0let obj = &#123;&#125; //最终返回的数据dedupeArr.forEach(i =&gt; &#123; count = 0 arr1.forEach(j =&gt; &#123; if (i === j) count++ &#125;) obj[i] = count //键名为i(数组元素)，值为count(出现次数)&#125;) 三、遍历对象12345678for(let i = 0 in obj)&#123; console.log(i+':'+obj[i]);&#125;// 数组元素:出现次数// 1:3// 2:3// 3:1// 4:1","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"rychou.github.io/tags/Javascript/"}]},{"title":"Js学习笔记：回调函数","slug":"Js学习笔记之回调函数","date":"2018-09-18T06:23:29.000Z","updated":"2018-11-17T11:32:12.125Z","comments":true,"path":"2018/09/18/Js学习笔记之回调函数/","link":"","permalink":"rychou.github.io/2018/09/18/Js学习笔记之回调函数/","excerpt":"A callback is a function that is passed as an argument to another function and is executed after its parent function has completed。 回调函数作为参数传递给另外一个函数，当另外一个函数执行完后再执行这个传递进去的函数（回调函数）。","text":"A callback is a function that is passed as an argument to another function and is executed after its parent function has completed。 回调函数作为参数传递给另外一个函数，当另外一个函数执行完后再执行这个传递进去的函数（回调函数）。 这里我看到一个网上一个很有意思的例子 约会结束后你送你女朋友回家，离别时，你肯定会说：“到家了给我发条信息，我很担心你。” 对不，然后你女朋友回家以后还真给你发了条信息。小伙子，你有戏了。其实这就是一个回调的过程。你留了个参数函数（要求女朋友给你发条信息）给你女朋友，然后你女朋友回家，回家的动作是主函数。她必须先回到家以后，主函数执行完了，再执行传进去的函数，然后你就收到一条信息了。 1234567891011function A(callback) &#123; callback() console.log('1')&#125;function B() &#123; setTimeout(console.log('2'), 3000)&#125;A(B)//输出//1//2 这里回调函数 B 是一个需要等待 3 秒才输出的，然而主函数不必等回调函数 B 执行完毕，可以继续执行自己的代码，然后再去执行回调函数 B。 所以回调函数一般用来做一些耗时的操作，如网络请求等，来实现异步操作。","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"rychou.github.io/tags/Javascript/"},{"name":"踩坑","slug":"踩坑","permalink":"rychou.github.io/tags/踩坑/"},{"name":"回调函数","slug":"回调函数","permalink":"rychou.github.io/tags/回调函数/"}]},{"title":"Js学习笔记：闭包","slug":"Js学习笔记之闭包","date":"2018-09-02T06:23:29.000Z","updated":"2018-11-17T12:30:06.732Z","comments":true,"path":"2018/09/02/Js学习笔记之闭包/","link":"","permalink":"rychou.github.io/2018/09/02/Js学习笔记之闭包/","excerpt":"一、前言这个周末，注意力都在学习基础 Js 知识上面，刚好看到了闭包这个神圣的东西，所以打算把这两天学到的总结下来，算是巩固自己所学。也可能有些不正确的地方，也请大家看到了，麻烦在评论下提醒一下，算是互相学习了。","text":"一、前言这个周末，注意力都在学习基础 Js 知识上面，刚好看到了闭包这个神圣的东西，所以打算把这两天学到的总结下来，算是巩固自己所学。也可能有些不正确的地方，也请大家看到了，麻烦在评论下提醒一下，算是互相学习了。 二、什么是闭包？ 百度百科定义：闭包就是能够读取其他函数内部变量的函数。 在解释之前，得先讲讲作用域。先来看下面这个示例： 123456var a = 1;function f()&#123; var b = 2; console.log(a) // 1&#125;console.log(b) // undefined 示例中包含了两种作用域，一种是属于全局的全局作用域，另一种是属于函数f的局部作用域。由于Javascript这种链式作用域(父作用域是可以被其子作用域访问的，而子作用域却不能被父作用域访问)的机制，使得示例最后一行输出了undefined 从此可以看出，无法从父作用域中访问子作用域。而我们再来看闭包的定义：闭包就是能够读取其他函数内部变量的函数。也就是闭包可以让我们从父作用域中访问到子作用域，具体怎么实现的呢？来看这个经典的例子： 1234567891011function foo()&#123; var a = 2; function bar()&#123; console.log(a); &#125; return bar;&#125;var baz = foo();baz(); // 2 -&gt; 这就是闭包的效果 这个示例中，闭包就是函数bar。可以看到，我们通过在函数foo内部定义其子函数bar，并将其作为foo返回值，因为bar函数作用域可以访问foo的作用域，所以实现了从全局作用域访问foo函数作用域的效果。 三、闭包的应用其实，平时你所写的代码中，早就用到了闭包，只是你还没发现而已。 本质上，无论何时何地，如果将函数当作值传递到其他地方使用（非函数所在作用域），你就已经使用了闭包。例如上面示例说的函数bar，我们将他传递到了全局作用域下，通过这种方式访问到本该不能访问的变量a。 在定时器、事件监听器、Ajax 请求、任何其他异步（或同步）任务中，只要使用了回调函数，实际上就是在使用闭包！ 四、注意事项闭包会让他所在作用域中的变量始终保存在内存中，而不会被垃圾回收机制回收。 12345678910111213141516171819function foo(p)&#123; function bar()&#123; console.log(++p); &#125; return bar;&#125;var baz = foo(1);baz(); // 2baz(); // 3baz(); // 4var bazz = foo(2);bazz(); // 3bazz(); // 4bazz(); // 5baz(); // 5 看到了没，闭包的使用，函数调用之后，让其外层函数的内部变量(foo函数内的变量)始终保存在了内存中，而不会被回收。 值得注意的是，每次调用一次foo，都会生成一个新的闭包，都会在内存中保存下其外层函数的内部变量。因此要注意闭包的使用，否则会导致性能问题。 五、总结闭包的作用： 能够读取其他函数内部变量。 让其他函数的内部变量始终保存在内存中。 参考： 阮一峰的 Javascript 入门教程——闭包 书籍：P43，你不知道的 Javascript 之闭包——上卷。 附：你不知道的 Javascript 系列电子书网盘链接， 密码：i8jf","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"rychou.github.io/tags/Javascript/"},{"name":"闭包","slug":"闭包","permalink":"rychou.github.io/tags/闭包/"}]},{"title":"Mpvue中使用Vant Weapp组件库","slug":"Mpvue中使用Vant Weapp组件库","date":"2018-08-31T06:25:08.000Z","updated":"2018-11-17T10:15:46.670Z","comments":true,"path":"2018/08/31/Mpvue中使用Vant Weapp组件库/","link":"","permalink":"rychou.github.io/2018/08/31/Mpvue中使用Vant Weapp组件库/","excerpt":"一、介绍mpvue-vant记录了我们团队开发中在mpvue中使用Vant Weapp组件库所踩下的坑，在这里分享给大家，让mpvue开发者可以使用vant组件库进行开发，避免踩不必要的坑。","text":"一、介绍mpvue-vant记录了我们团队开发中在mpvue中使用Vant Weapp组件库所踩下的坑，在这里分享给大家，让mpvue开发者可以使用vant组件库进行开发，避免踩不必要的坑。 此教程是在dov-yih一同协助下完成。经过测试，Vant Weapp下所有组件都能够在mpvue中使用 demo 地址 更新日志 二、使用方法 目前 vant 已经支持了npm的方式，但是由于node_modules目录下的代码是不会被编进dist目录下的，所以暂时只能用git方式使用。 克隆 vant 仓库将dist目录下的所有文件复制到你项目的/static/vant/目录下。 1git clone https://github.com/youzan/vant-weapp.git 12// 当然你也可以克隆本仓库代码，本仓库会与`vant`仓库保持同步。直接将`vant`目录复制到`/static`目录下git clone https://github.com/xxxsimons/mpvue-vant.git 引入在需要引入的页面目录下的main.json文件中 12345&#123; \"usingComponents\": &#123; \"van-button\": \"/static/vant/button/index\", &#125;&#125; 使用1&lt;van-button&gt;测试&lt;/van-button&gt; 三、注意事项具体组件 api 文档参考Vant Weapp 1. 使用方式mpvue 和原生小程序的方式有所不同。可以参考mpvue 文档 1.1 数据绑定原生小程序使用方式为 1value=\"&#123;&#123;value&#125;&#125;\" mpvue 使用方式 123v-bind:value=\"value\"//或者:value=\"value\" 1.2 事件监听原生小程序使用方式 1bind:click=\"onClick\" mpvue 使用方式 1@click=\"onClick\" 1.3 vue 中组件引入vant中像notify这种操作反馈类的组件都有两个引入，一是组件的引入，这个在main.json中引入；另一个是方法的引入，需要在vue文件中import引入，值得注意的是，这里的引入不能使用绝对路径，可以用类似于这样的相对路径。 1import Notify from '@/../static/notify/notify' //@是mpvue的一个别名，指向src目录 1.4 获取 event值得注意的是，mpvue中获取event值与原生小程序有所不同。举例： 123onChange(event)&#123; // 获取表单组件filed的值 console.log(event.mp.detail) // 注意加入mp&#125; 2. BUG 及报错处理方法2.1 监听名mpvue 里面无法使用@click-icon这样的监听名,因此如果 API 文档里面有出现这样的监听名，那么需要手动修改源代码。 可以改成驼峰式的监听名。 eg: 我在field组件中就遇到这个问题，我的做法是： 1234567// static/vant/field/index.jsthis.$emit('click-icon');// 修改为:this.$emit('clickIcon'); 2.2 报错一般的报错报错都可以通过一下流程处理。 是否打开了微信开发者工具中的ES6转ES5功能。 仔细检查代码和比对文档，看看是否有使用不当的地方。 重新编译npm run dev或删掉dist目录重新npm run dev 重启或更新微信开发者工具。 若以上流程都走完了，还是无法解决报错，可以通过提交issues的方式，我来帮你解决。 2.2.1 引入组件报错1VM54:1 thirdScriptError sdk uncaught third Error module \"static/vant/notify/index.js\" is not defined 解决办法是：打开小程序开发者工具中的ES6 转 ES5功能. issues/#5 3. 其他组件库目前比较好的组件库有三个，Wux Weapp,iview weapp,Vant Weapp。 这三者都是用原生小程序写的组件库，因此理论上来说，在 mpvue 中都是可以无缝使用的。不同组件库的组件都不一样，有的更丰富，有的逻辑更完善，有的文档更清晰。因此用什么组件，还需要自己取舍。 比如：三者中，唯有Wux Weapp有日历组件，而且它里面还有一些更高级的组件可以使用。 使用方法上，几乎没有差异。值得注意的是，大家复制源代码到自己项目上时，应该复制/dist/目录下的文件。因为这里是经过编译后的。 如果大家使用过程中遇到什么 BUG，可以通过提issues的方式让我知道，大家一起踩坑吧！ 分享一个 Demo作者基于 vant 和 wux 组件库,以及最新的小程序云开发开发的一个小程序。以及总结了mpvue中使用云开发的注意事项，mpvue-cloud 猫叫助手|收录各种猫叫声，帮助与猫咪交流，分享一些养猫的小知识等。","categories":[],"tags":[{"name":"mpvue","slug":"mpvue","permalink":"rychou.github.io/tags/mpvue/"},{"name":"vant","slug":"vant","permalink":"rychou.github.io/tags/vant/"}]},{"title":"小程序分享功能报错问题解决方案","slug":"小程序分享功能报错问题解决方案","date":"2018-08-30T06:25:08.000Z","updated":"2018-11-17T10:13:55.214Z","comments":true,"path":"2018/08/30/小程序分享功能报错问题解决方案/","link":"","permalink":"rychou.github.io/2018/08/30/小程序分享功能报错问题解决方案/","excerpt":"报错信息12345678910111213thirdScriptErrorCannot read property 'apply' of null;at pages/client/home/main page onShareAppMessage functionTypeError: Cannot read property 'apply' of null at t.l (http://127.0.0.1:62595/appservice/__dev__/WAService.js:18:30625) at dn (http://127.0.0.1:62595/appservice/__dev__/WAService.js:20:2360) at Function.pn (http://127.0.0.1:62595/appservice/__dev__/WAService.js:20:3321) at http://127.0.0.1:62595/appservice/__dev__/WAService.js:19:1368 at http://127.0.0.1:62595/appservice/__dev__/WAService.js:20:4179 at n (http://127.0.0.1:62595/appservice/__dev__/WAService.js:6:8644) at a (http://127.0.0.1:62595/appservice/appservice?t=1535626735316:3056:9566) at e.registerCallback (http://127.0.0.1:62595/appservice/appservice?t=1535626735316:3056:9753) at n.forEach (http://127.0.0.1:62595/appservice/appservice?t=1535626735316:3056:5638) at Array.forEach (&lt;anonymous&gt;)","text":"报错信息12345678910111213thirdScriptErrorCannot read property 'apply' of null;at pages/client/home/main page onShareAppMessage functionTypeError: Cannot read property 'apply' of null at t.l (http://127.0.0.1:62595/appservice/__dev__/WAService.js:18:30625) at dn (http://127.0.0.1:62595/appservice/__dev__/WAService.js:20:2360) at Function.pn (http://127.0.0.1:62595/appservice/__dev__/WAService.js:20:3321) at http://127.0.0.1:62595/appservice/__dev__/WAService.js:19:1368 at http://127.0.0.1:62595/appservice/__dev__/WAService.js:20:4179 at n (http://127.0.0.1:62595/appservice/__dev__/WAService.js:6:8644) at a (http://127.0.0.1:62595/appservice/appservice?t=1535626735316:3056:9566) at e.registerCallback (http://127.0.0.1:62595/appservice/appservice?t=1535626735316:3056:9753) at n.forEach (http://127.0.0.1:62595/appservice/appservice?t=1535626735316:3056:5638) at Array.forEach (&lt;anonymous&gt;) 原因这是因为你将onShareAppMessage()这个页面级的方法写到组件中导致的错误，解决办法就是将其写到页面内。","categories":[],"tags":[{"name":"小程序","slug":"小程序","permalink":"rychou.github.io/tags/小程序/"}]},{"title":"小程序输入框闪烁BUG解决方案","slug":"小程序输入框闪烁BUG解决方案","date":"2018-08-30T06:25:08.000Z","updated":"2018-11-17T10:14:37.683Z","comments":true,"path":"2018/08/30/小程序输入框闪烁BUG解决方案/","link":"","permalink":"rychou.github.io/2018/08/30/小程序输入框闪烁BUG解决方案/","excerpt":"前言 本人所说的小程序，都是基于mpvue框架而上的，因此BUG可能是原生小程序的，也有可能是mpvue的。","text":"前言 本人所说的小程序，都是基于mpvue框架而上的，因此BUG可能是原生小程序的，也有可能是mpvue的。 问题描述在小程序input组件中，如果使用v-model进行双向绑定，在输入时会出现光标闪烁的BUG。 原因造成这个 BUG 的原因，是因为在原生小程序input组件上，进行了封装。才导致光标闪烁的问题。 解决方案这里提供了两种解决方案。各有各的优势，请选取合适的方案： 一、弃用v-model,使用@input适用于input组件单纯是用户手动输入的，而没有像授权获取手机号，然后自动填入input组件中。这种需要赋予初始value的情况。即适用于单向绑定，而不是双向绑定。 123456789101112131415161718192021222324252627282930/*** 父组件*/// html&lt;childInput @input=\"onInput\"/&gt; &lt;-- 注意这里不能使用:value=value赋予初始值，否则又会出现闪烁的BUG，因为此时就等同于v-model了// jsimport ChildInput from './ChildInput'export default &#123; components:&#123; ChildInput &#125;, data()&#123; return &#123; value:'' &#125; &#125;, methods()&#123; onInput(e)&#123; this.value = e &#125; &#125;&#125;/*** 子组件 ChildInput*/// html&lt;input @input=\"$emit('input',$event)\"/&gt; 二、不封装input组件，直接使用v-model这种情况就是可以直接双向绑定的了。具体原因还不清楚，可能是本身原生小程序的 BUG。 123456789101112131415/*** 父组件,不使用封装的子组件，直接使用原生组件。*/// html&lt;input v-model=\"value\"/&gt;// jsexport default &#123; data()&#123; return &#123; value:'' &#125; &#125;&#125;","categories":[],"tags":[{"name":"小程序","slug":"小程序","permalink":"rychou.github.io/tags/小程序/"}]},{"title":"为你的博客添加目录索引","slug":"为你的博客添加目录索引","date":"2018-08-21T06:25:08.000Z","updated":"2018-11-17T10:08:31.677Z","comments":true,"path":"2018/08/21/为你的博客添加目录索引/","link":"","permalink":"rychou.github.io/2018/08/21/为你的博客添加目录索引/","excerpt":"一、前言演示图例","text":"一、前言演示图例 需求这个目录索引应该包含以下功能： 点击目录项跳转到对应锚点 屏幕滚动时，对应目录项样式变化 话不多说，开始干！ 二、点击目录项跳转到对应锚点hash 模式的路由下的锚点说到文章的目录索引，首先想到的就是锚点了。然而在hash模式的路由下，如果使用原始的锚点方案会造成下面这样的问题。 123456// 文章url链接,hash模式下www.rychou.xyz/#/article/70// 如果采用传统的锚点方式，比如有个锚点：anchor-1，点击之后，url会变成www.rychou.xyz/#anchor-1 很明显，在hash模式下，就不能采用这种方式锚点了。我采用了自定义锚点的方式。 参考：vue2.0 中怎么做锚点定位 添加锚点和初始化目录的数据结构方法有了，然后就是怎么给文章加添加锚点了。 我采用了遍历 dom 树，然后找到文章的h1标签（暂时只对h1标签建立索引），为其添加id的方式建立索引。 1234567891011// 初始化文章锚点和目录数据结构getDirectories() &#123; let directories = document.querySelectorAll(\".article-content h1\"); //找到属于文章内容的h1标签 directories.forEach((element, index) =&gt; &#123; element.id = \"anchor-\" + index;//添加id this.directories.push(&#123; title: element.innerText, //h1标签文本内容 offsetTop: element.offsetTop, //记录当前h1标签的偏移量，方便后面计算滚动距离。 isActive: false //是否被选中 &#125;); &#125;); 实现点击跳转到对应锚点123456789101112&lt;div v-for=\"(item,index) in directories\" :key=\"index\"&gt; &lt;a href=\"javascript:void(0)\" @click=\"goAnchor(index)\" &gt; &#123;&#123;item.title&#125;&#125; &lt;/a&gt;&lt;/div&gt;methods:&#123; goAnchor(index) &#123; document.documentElement.scrollTop = this.directories[index].offsetTop; &#125;,&#125; 三、屏幕滚动时，对应目录项样式变化注意我们前面初始化目录数据结构中，包含了一个叫isActive的状态位，就是根据这个状态位来进行相应的渲染 动态绑定class12345678910&lt;div class=\"directories-container\"&gt; &lt;div class=\"directories-list\"&gt; &lt;h2&gt;目录&lt;/h2&gt; &lt;div :class=\"&#123;'highlight-title':item.isActive&#125;\" v-for=\"(item,index) in directories\" :key=\"index\" style=\"padding: 5px 12px;\"&gt; &lt;a href=\"javascript:void(0)\" @click=\"goAnchor(index)\" &gt; &#123;&#123;item.title&#125;&#125; &lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 添加滚动监听12345678// 挂载页面时，添加滚动监听mounted() &#123; window.addEventListener(\"scroll\", this.handleScroll); &#125;,// 退出页面时，应该取消监听destroyed() &#123; window.removeEventListener(\"scroll\", this.handleScroll);&#125;, 计算状态位isActive12345678910111213handleScroll(e) &#123; let scrollTop = document.documentElement.scrollTop //当前滚动距离 this.directories.forEach((element,index)=&gt;&#123; if((scrollTop)&gt;=element.offsetTop)&#123;//当前滚动距离大于某一目录项时。 for(let i=0;i&lt;index;i++)&#123; this.directories[i].isActive = false //同一时刻，只能有一个目录项的状态位为Active，即此时其他目录项的isActive = false &#125; element.isActive = true; //将对应的目录项状态位置为true &#125;else&#123; element.isActive = false; &#125; &#125;)&#125; css 样式12345678910111213141516171819202122232425262728// scss.directories-container &#123; width: 15vw; transition: all 0.5s; margin-left: 10px; .highlight-title &#123; border-left: 3px solid rgb(15, 105, 223); background-color: rgb(243, 243, 243); z-index: -1; a&#123; color: rgb(15, 105, 223) &#125; &#125; .directories-list &#123; position: -webkit-sticky; position: sticky; top: 0; word-wrap: break-word; background-color: #fff; border-left: 1px solid rgb(236, 236, 236); z-index: 999; a &#123; &amp;:hover &#123; text-decoration: underline; &#125; &#125; &#125;&#125;","categories":[],"tags":[{"name":"目录","slug":"目录","permalink":"rychou.github.io/tags/目录/"}]},{"title":"用gitalk给你的博客添加评论服务","slug":"用gitalk给你的博客添加评论服务","date":"2018-08-18T06:28:03.000Z","updated":"2018-11-17T10:06:49.978Z","comments":true,"path":"2018/08/18/用gitalk给你的博客添加评论服务/","link":"","permalink":"rychou.github.io/2018/08/18/用gitalk给你的博客添加评论服务/","excerpt":"一、前言不像 hexo、jekyll 等，为了学习，我的博客是用vue和nodejs搭建出来的。支持在线编辑和 markdown 渲染等功能。 大家如果感兴趣可以看我的博客地址 最近给自己的博客添加了评论服务，用到的评论服务是Gitalk，它是基于github issue搭建出来的评论系统。废话不多说，接下来说说如何使用。","text":"一、前言不像 hexo、jekyll 等，为了学习，我的博客是用vue和nodejs搭建出来的。支持在线编辑和 markdown 渲染等功能。 大家如果感兴趣可以看我的博客地址 最近给自己的博客添加了评论服务，用到的评论服务是Gitalk，它是基于github issue搭建出来的评论系统。废话不多说，接下来说说如何使用。 二、必要的准备在 Github 创建一个用来存放评论的仓库当然你也可以直接用你博客所在的仓库，因为我的博客部署到了coding pages，所以我单独创建了一个仓库用来存放评论。 注册一个Github OAuth application没有的可以点这里申请 注册成功后，记录下你的clientID和clientSecret。 三、安装有两种方式安装(CDN 和 npm)，大家可自行选择。 1. CDN1234567&lt;link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css\"&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js\"&gt;&lt;/script&gt;&lt;!-- or --&gt;&lt;link rel=\"stylesheet\" href=\"https://unpkg.com/gitalk/dist/gitalk.css\"&gt;&lt;script src=\"https://unpkg.com/gitalk/dist/gitalk.min.js\"&gt;&lt;/script&gt; 2. npm1npm i --save gitalk 四、使用考虑到vue的生命周期等，使用方法上和官方文档给出来的是需要做略微的调整的。 引入 gitalk123456//在index.html页面中CDN引入&lt;link rel=\"stylesheet\" href=\"https://unpkg.com/gitalk/dist/gitalk.css\"&gt;&lt;script src=\"https://unpkg.com/gitalk/dist/gitalk.min.js\"&gt;//在vue中importimport Gitalk from 'gitalk' 初始化 Gitalk 实例123456789101112131415export default &#123; data()&#123; return&#123; gitalk: new Gitalk(&#123; clientID: \"你的clientID\", clientSecret: \"你的clientSecret\", repo: \"刚刚创建的项目名\", owner: \"github用户名\", admin: [\"github用户名\"], id: window.location.hash, // 默认为pathname,如果你也是像我这样用vue搭建的，我建议使用hash，原因具体后面会讨论到。 distractionFreeMode: false // Facebook-like distraction free mode &#125;) &#125; &#125;&#125; 在恰当的位置添加标签,用来渲染 Gitalk 组件。1&lt;div id=\"gitalk-container\"&gt;&lt;/div&gt; 渲染123mounted()&#123; this.gitalk.render(\"gitalk-container\");&#125; 五、注意事项id 的设置这个 id 是用来唯一区分页面的，也就是你不同的文章肯定有不同的评论数据，Gitalk要通过这个 id 来区分是哪个页面，然后在你的github仓库创建相应的issue来存放当页评论数据，id默认值是window.location.pathname 但是默认的只适用于采用history模式的路由，但对于vue-router这种默认采用hash模式的就不行了。 举个例子 123456789//在history模式下，路由URL如下格式www.rychou.xyz/article/69window.location.pathname;// 值是 /article/69//在hash模式下，路由变成这样了www.rychou.xyz/#/article/69window.location.pathname; // 值是 / 此时，在hash模式下id就不具有唯一性了。 建议使用window.location.hash，此时的值是#/aticle/69,具有唯一性。 当然你也可以设置vue-router为history模式，但是这会有一个刷新页面出现 404 的 BUG，解决办法参考官方文档 不使用类似的评论服务Gitment的原因我也试过用Gitment，也成功了，但是有一个非常令人不爽的地方，就是每一篇文章都需要手动初始化(创建相应 issue)，因此我还是用了Gitalk,它会根据你的配置，自动帮你初始化。 六、最后有问题的同学们，欢迎来原文下方提问，同时也相当于帮我测试一下评论服务了。 参考链接： Gitalk Gitment 官方文档- vue-router History 模式","categories":[],"tags":[{"name":"Gitalk","slug":"Gitalk","permalink":"rychou.github.io/tags/Gitalk/"}]},{"title":"用shelljs实现前端部署自动化","slug":"用shelljs实现前端部署自动化","date":"2018-08-17T06:28:03.000Z","updated":"2018-11-17T10:06:53.923Z","comments":true,"path":"2018/08/17/用shelljs实现前端部署自动化/","link":"","permalink":"rychou.github.io/2018/08/17/用shelljs实现前端部署自动化/","excerpt":"一、场景在前端开发过程中，你肯定经常使用到以下等命令： 1234npm run buildgit add .git commit -m 'commit'git push","text":"一、场景在前端开发过程中，你肯定经常使用到以下等命令： 1234npm run buildgit add .git commit -m 'commit'git push 本人在用vue-cli写我的个人博客时，将其部署到coding pages上。不用github pages的原因纯粹是因为慢。。。每一次部署，都要将上面的命令敲一遍，实在令我很痛苦。如果能用一条命令执行以上所有任务，那就爽多了。 话不多说，说干就干。 二、Shelljs这个库能够让我们在js文件中执行 shell 命令，具体可以看文档。 安装1npm install [-g] shelljs 有两种使用方式，一种是全局模式(对应全局安装),一种是局部模式。看下面的使用案例就知道两者区别。 三、使用在根目录下新建文件shell.js，内容如下： 1234567891011121314151617//局部模式var shell = require('shelljs');//全局模式下，就不需要用shell开头了。//require('shelljs/global');if (shell.exec('npm run build').code !== 0) &#123;//执行npm run build 命令 shell.echo('Error: Git commit failed'); shell.exit(1);&#125;//由于我的用另外一个仓库存放dist目录，所以这里要将文件增量复制到目标目录。并切换到对应目录。shell.cp ('-r', './dist/*', '../../Rychou');shell.cd('../../Rychou');shell.exec('git add .');shell.exec(\"git commit -m 'autocommit'\")shell.exec('git push') 这时在根目录下执行node shell.js就可以了 这里只是最简单的使用案例。 四、再让它更方便些在package.json中加入： 123\"script\":&#123;+ \"push\":\"node ./shell.js\"&#125; 在根目录下执行npm run push就搞定了。 参考链接：Shelljs","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"rychou.github.io/tags/Javascript/"},{"name":"前端自动化","slug":"前端自动化","permalink":"rychou.github.io/tags/前端自动化/"}]},{"title":"Js学习笔记：apply与call","slug":"Js学习笔记之apply与call","date":"2018-08-15T06:32:20.000Z","updated":"2018-11-17T11:32:18.725Z","comments":true,"path":"2018/08/15/Js学习笔记之apply与call/","link":"","permalink":"rychou.github.io/2018/08/15/Js学习笔记之apply与call/","excerpt":"一、apply 与 call 的区别相同点：“可以让一个对象调用另一个对象的方法” 不同点： apply 最多只能传入两个参数，第一个为对象，第二个为数组 call 能传入多个参数，第一个为对象，其后为 n 个参数列表","text":"一、apply 与 call 的区别相同点：“可以让一个对象调用另一个对象的方法” 不同点： apply 最多只能传入两个参数，第一个为对象，第二个为数组 call 能传入多个参数，第一个为对象，其后为 n 个参数列表 实际上，apply 和 call 实现的功能是一样的，只是传入的参数不同而已。 示例: 12345678910111213function add(a,b)&#123; return a+b;&#125;function sub(a,b)&#123; return a-b;&#125;var a1 = add.apply(sub,[4,2]); //sub调用add的方法var a2 = sub.apply(add,[4,2]);alert(a1); //6alert(a2); //2/*call的用法*/var a1 = add.call(sub,4,2); apply 的一些使用技巧 配合Math.max()计算数组最大值 因为Math.max()不支持数组的方式，只能Math.max(a,b,c....)。根据 apply 的特点来实现这一功能，Math.max.apply(null,[1,2,3]),因为没有新的对象调用 Math 的 max 方法，所以只是传入 null 来利用 apply 的特性帮助进行计算而已。 apply 会将数组中的每个元素一个个传入给 Math.max()。也就相当于Math.max.call(null,1,2,3) 同理可以用Math.min.apply(null,[1,2,3])计算数组最小值 配合 Array.prototype.push 实现两个数组合并 数组的 push 方法是不能 push 数组的，但是可以同时 push 多个元素，因此可以利用 apply 的特性 1234var a = [1,2,3];var b = [4,5,6];Array.prototype.push.apply(a,b);//apply会将为b中每一个元素执行一次push方法。返回值是push后数组a的长度 参考链接:apply()与 call()的区别 二、Object.prototype.toString.call()进行类型检验首先来看一个问题，用 typeof 来检验类型有什么缺点呢？ 答案是 typeof 无法准确地检验对象类型。 12typeof null //objecttypeof [] //object null的类型是object，这是由于历史原因造成的。1995 年的 JavaScript 语言第一版，只设计了五种数据类型（对象、整数、浮点数、字符串和布尔值），没考虑null，只把它当作object的一种特殊值。后来null独立出来，作为一种单独的数据类型，为了兼容以前的代码，typeof null返回object就没法改变了。 比较好的方式就是用 Object.prototype.toString.call()来进行检验。 12345678910var a = &#123;&#125;;var b = [];var c = 1;Object.prototype.toString.call(a);//[object,Object]Object.prototype.toString.call(b);//[object,Array]Object.prototype.toString.call(c);//[object,Number]//判断a是否是对象类型Object.prototype.toString.call(a) === \"[object,Object]\" 注意：使用 obj.toString()是不能得到类型的。原因：Array,Function 等类型作为 Object 的实例，都重写的了 toString 方法。因此在调用时，是调用了重写后的方法，而不是原型链上的 toString()方法 123456var arr=[1,2,3];console.log(Array.prototype.hasOwnProperty(\"toString\"));//trueconsole.log(arr.toString());//1,2,3delete Array.prototype.toString;//delete操作符可以删除实例属性console.log(Array.prototype.hasOwnProperty(\"toString\"));//falseconsole.log(arr.toString());//\"[object Array]\" 删除了重写的方法后，使用 obj.toString()也就相当于调用原型链的方法了，即 Object.prototype.toString.call() 参考链接: 为什么用 Object.prototype.toString.call(obj)检测对象类型? 深入理解 Object.prototype.toString.call()","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"rychou.github.io/tags/Javascript/"}]},{"title":"小程序实现长按录音，上划取消发送","slug":"小程序实现长按录音,上划取消发送","date":"2018-07-23T06:28:03.000Z","updated":"2018-11-17T11:32:30.291Z","comments":true,"path":"2018/07/23/小程序实现长按录音,上划取消发送/","link":"","permalink":"rychou.github.io/2018/07/23/小程序实现长按录音,上划取消发送/","excerpt":"最近在使用 mpvue 开发小程序，需要用到录音功能，于是打算参照微信的录音方案：”长按录音松开发送，上划取消发送”。在网上找了一圈都没发现相似的案例，没办法只能自己实现。 下面讲解只贴上关键代码","text":"最近在使用 mpvue 开发小程序，需要用到录音功能，于是打算参照微信的录音方案：”长按录音松开发送，上划取消发送”。在网上找了一圈都没发现相似的案例，没办法只能自己实现。 下面讲解只贴上关键代码 1. html 部分。微信小程序事件接口： 类型 触发条件 touchstart 手指触摸动作开始 touchmove 手指触摸后移动 touchend 手指触摸动作结束 longpress 手指触摸后，超过 350ms 再离开，如果指定了事件回调函数并触发了这个事件，tap 事件将不被触发 longtap 手指触摸后，超过 350ms 再离开（推荐使用 longpress 事件代替） 分析:长按录音需要 longpress 事件，松开发送需要 touchend 事件，上滑取消发送需要 touchmove 事件。由此可有以下 html 代码 12345//html部分 class部分只是控制样式 与功能无关&lt;div class=\"input weui-grid\" hover-class=\"weui-grid_active\" :class=\"record.type\" @longpress=\"handleRecordStart\" @touchmove=\"handleTouchMove\" @touchend=\"handleRecordStop\"&gt; &lt;image class=\"weui-grid__icon\" :src=\"record.iconPath\"/&gt; &lt;div class=\"weui-grid__label\"&gt;&#123;&#123;record.text&#125;&#125;&lt;/div&gt;&lt;/div&gt; 2. JS 部分2.1. 首先定义录音的数据结构：旧版的小程序录音接口 wx.startRecord 和 wx.stopRecord 在 1.6.0 版本后不再维护了，所以使用其建议的wx.getRecordManager接口。 注意:使用 wx.getRecordManager 接口的话,应调用相应的音频控制接口wx.createInnerAudioContext()来播放和控制录音. 123456789101112data()&#123; record: &#123; text: \"长按录音\", type: \"record\", iconPath: require(\"@/../static/icons/record.png\"), handler: this.handleRecordStart &#125;, //与录音相关的数据结构 recorderManager: wx.getRecorderManager(), //录音管理上下文 startPoint: &#123;&#125;, //记录长按录音开始点信息,用于后面计算滑动距离。 sendLock: true, //发送锁，当为true时上锁，false时解锁发送 &#125;, 2.2. 监听录音 stop123456789101112131415onLoad()&#123; this.recorderManager.onStop(res =&gt; &#123; if (this.sendLock) &#123; //上锁不发送 &#125; else &#123;//解锁发送，发送网络请求 if (res.duration &lt; 1000) wx.showToast(&#123; title: \"录音时间太短\", icon: \"none\", duration: 1000 &#125;); else this.contents = [...this.contents,&#123; type: \"record\", content: res &#125;];//contents是存储录音结束后的数据结构,用于渲染. &#125; &#125;);&#125; 2.3. 长按录音方法在这个方法中需要做的事: 记录长按的点信息,用于后面计算手指滑动的距离,实现上滑取消发送. 做一些界面样式的控制. 开始录音 123456789101112131415161718handleRecordStart(e) &#123; //longpress时触发 this.startPoint = e.touches[0];//记录长按时开始点信息，后面用于计算上划取消时手指滑动的距离。 this.record = &#123;//修改录音数据结构，此时录音按钮样式会发生变化。 text: \"松开发送\", type: \"recording\", iconPath: require(\"@/../static/icons/recording.png\"), handler: this.handleRecordStart &#125;; this.recorderManager.start();//开始录音 wx.showToast(&#123; title: \"正在录音，上划取消发送\", icon: \"none\", duration: 60000//先定义个60秒，后面可以手动调用wx.hideToast()隐藏 &#125;); this.sendLock = false;//长按时是不上锁的。 &#125;, 2.4. 松开发送在这个方法中需要做的事: 做一些样式的控制. 结束录音. 1234567891011handleRecordStop() &#123; // touchend(手指松开)时触发 this.record = &#123;//复原在start方法中修改的录音的数据结构 text: \"长按录音\", type: \"record\", iconPath: require(\"@/../static/icons/record.png\"), handler: this.handleRecordStart &#125;; wx.hideToast();//结束录音、隐藏Toast提示框 this.recorderManager.stop();//结束录音&#125; 2.5. 上划取消发送在这个方法中需要做的事: 计算手指上滑的距离 根据距离判断是否需要取消发送 如果取消发送,最重要的是 this.sendLock = true,上锁不发送 1234567891011121314151617181920 handleTouchMove(e) &#123; //touchmove时触发 var moveLenght = e.touches[e.touches.length - 1].clientY - this.startPoint.clientY; //移动距离 if (Math.abs(moveLenght) &gt; 50) &#123; wx.showToast(&#123; title: \"松开手指,取消发送\", icon: \"none\", duration: 60000 &#125;); this.sendLock = true;//触发了上滑取消发送，上锁 &#125; else &#123; wx.showToast(&#123; title: \"正在录音，上划取消发送\", icon: \"none\", duration: 60000 &#125;); this.sendLock = false;//上划距离不足，依然可以发送，不上锁 &#125; &#125;,&#125; 2.6. 演示 GIF","categories":[],"tags":[{"name":"mpvue","slug":"mpvue","permalink":"rychou.github.io/tags/mpvue/"},{"name":"小程序","slug":"小程序","permalink":"rychou.github.io/tags/小程序/"},{"name":"录音","slug":"录音","permalink":"rychou.github.io/tags/录音/"}]},{"title":"vue和小程序踩坑指南","slug":"vue和小程序踩坑指南","date":"2018-07-19T06:25:08.000Z","updated":"2018-11-17T06:27:12.610Z","comments":true,"path":"2018/07/19/vue和小程序踩坑指南/","link":"","permalink":"rychou.github.io/2018/07/19/vue和小程序踩坑指南/","excerpt":"一、参考文档 小程序官方 Api 文档 mpvue 官方文档 vue 官方文档","text":"一、参考文档 小程序官方 Api 文档 mpvue 官方文档 vue 官方文档 二、工具篇1. VSCode 插件 Eslint 格式化代码插件，在写代码时提示格式以及保存代码时自动格式化代码。配置教程 mpvue snippets 小程序和 mpvue 代码提示 Vetur Vue 开发工具 2. normalize 前端解析 Json API12345678a:&#123; 1:&#123; type:'', id:'' &#125;&#125;对于这种对象的key为数字的，然而并不知道数字是啥，可以使用a[Object.keys(a)[0]]来访问第一个元素 3. mpvue-router-patch在 mpvue 中使用 vue-router 的写法4. flyio 发起网络请求5. 封装小程序 API，实现异步调用1234567891011121314151617181920212223242526// WXP.js// 核心function f (func, obj) &#123; return new Promise((resolve, reject) =&gt; &#123; func(&#123; ...obj, success: resolve, fail: reject &#125;) &#125;)&#125;export default &#123; // 获取认证 code login: obj =&gt; f(wx.login, obj),&#125;//使用import WXP from 'WXP'WXP.login(&#123;&#125;) .then(res=&gt;&#123;&#125;) .catch(err=&gt;&#123;&#125;) 6. Promise 实现 finally.1234567891011// 安装npm i --save promise.prototype.finally// main.js引入require('promise.prototype.finally').shim();// 使用promise()//某个异步操作.then().catch().finally() 三、踩坑1.修改 v-html 渲染的标签样式不生效的问题产生原因：在中加了 scoped 属性，这个属性的作用是让样式私有化（只在本组件生效）。而使用了 v-html 之后，其实际是被当成子组件了，因此导致样式不生效 解决办法：去掉中的 scoped 12345678910111213141516&lt;template&gt; &lt;div v-html=\"htmlString\"&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default&#123; data()&#123; return()&#123; htmlString:''//要渲染的html字符串 &#125; &#125;&#125;&lt;/script&gt;&lt;style lang=\"scss\"&gt;//去掉scoped&lt;/style&gt; 2. 如何在 vue 中使用 hightlight.js 高亮你的代码安装 highlight.js1npm install highlight.js --save 在顶层 main.js 中加入以下代码段12345678910import hljs from 'highlight.js'import 'highlight.js/styles/monokai.css'//样式文件//vue自定义指令，检索所有的code标签进行高亮Vue.directive('highlight',function (el) &#123; let blocks = el.querySelectorAll('code'); blocks.forEach((block)=&gt;&#123; hljs.highlightBlock(block) &#125;)&#125;) 在你文章的顶层标签加入自定义指令 v-highlight1&lt;div class=\"article-body\" v-html=\"compileMarkdown\" v-highlight&gt;&lt;/div&gt; 3. 不要在 computed 内使用 split()方法4.wx.showToast({title:’text’,image:’/state/xx.png’})需要用绝对路径5. &lt;scroll-view&gt;&lt;/scroll-view&gt;组件5.1. 如若需要竖向滚动，则需要设置固定高度，并且单位不能为 rpx（设置成 rpx 会有显示的问题，显示不全）123456789101112131415&lt;scroll-view :scroll-y=\"true\" :style=\"&#123;'height': scrollHeight+'px;','padding-top':'100rpx'&#125;\" //切不要设置成rpx，否则会出现显示不全的bug :enable-back-to-top=\"true\" @scrolltolower=\"loadData\" &gt;...&lt;/scroll-view&gt;//获取屏幕高度wx.getSystemInfo(&#123; success: res =&gt; &#123; this.scrollHeight = parseInt(res.windowHeight); &#125; &#125;); 5.2.使用&lt;scroll-view&gt;&lt;/scroll-view&gt;组件与onPullDownRefresh不能同时使用参考：微信小程序—下拉刷新上拉加载 6. 录音6.1. 格式问题导致录音无法播放。小程序推荐使用的录音管理上下文wx.getRecorderManager()支持的录音格式有两种:aac/mp3。如果不指定格式，在安卓端录音的文件格式是 m4a 的，会导致无法播放。 所以需要在录音时手动设置格式为mp3格式，aac会有播放不全的 BUG 123this.recordManager.start(&#123; format: 'mp3' //&#125;)","categories":[],"tags":[{"name":"踩坑","slug":"踩坑","permalink":"rychou.github.io/tags/踩坑/"},{"name":"小程序","slug":"小程序","permalink":"rychou.github.io/tags/小程序/"},{"name":"Vue","slug":"Vue","permalink":"rychou.github.io/tags/Vue/"}]},{"title":"小程序Tabs懒加载","slug":"小程序Tabs懒加载","date":"2018-07-17T06:26:31.000Z","updated":"2018-11-17T06:27:31.564Z","comments":true,"path":"2018/07/17/小程序Tabs懒加载/","link":"","permalink":"rychou.github.io/2018/07/17/小程序Tabs懒加载/","excerpt":"小程序用 mpvue 编写 v-if 和:hidden 的区别这两种方式都可以用来控制组件的显示与隐藏，但他们实现原理上有所不同。","text":"小程序用 mpvue 编写 v-if 和:hidden 的区别这两种方式都可以用来控制组件的显示与隐藏，但他们实现原理上有所不同。 v-if：这是条件渲染，只有当其为 true 时，才会渲染出来:hidden：这只是控制组件的显示与隐藏，会将所有组件都在开始的时候全部加载，只是有的组件没有显示而已。 v-if 有更高的切换消耗（切换会有旧组件销毁和新组件挂载），而 hidden 有更高的初始渲染消耗（在初始就挂载所有组件）。所以 hidden 更适合用于频繁切换 使用 hidden 实现懒加载 在父组件用 hidden 控制组件隐藏显示 12345678910111213141516171819202122232425262728index.vue//父组件----------------------------...&lt;template&gt;&lt;div class=\"weui-tab__panel\"&gt; &lt;div class=\"weui-tab__content\" :hidden=\"hiddens[index]\" v-for=\"(tab,index) in tabs\" :key=\"index\" &gt;//在tab内容组件外面一层用hidden控制组件隐藏 &lt;list-delegate :hidden=\"hiddens[index]\"/&gt;//这里将hidden属性传入tab内容子组件内部，其内部根据hidden进行相关的控制。 &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;...&lt;script&gt;export default&#123; data()&#123; return()&#123; tabs: [\"推荐\", \"热门\", \"我的\"], activeIndex: 0, &#125; &#125; computed: &#123; hiddens()&#123; return [this.activeIndex!=0,this.activeIndex!=1,this.activeIndex!=2]//hiddens数组，计算当前hidden的tab，一共有3个tab &#125;........&#125;&lt;/script&gt;-------------------------------------- 2.在 tab 内容子组件用传入的 hidden 属性进行相关的控制 12","categories":[],"tags":[{"name":"踩坑","slug":"踩坑","permalink":"rychou.github.io/tags/踩坑/"},{"name":"小程序","slug":"小程序","permalink":"rychou.github.io/tags/小程序/"}]},{"title":"在富文本编辑器之外使用quill富文本样式","slug":"在富文本编辑器之外使用quill富文本样式","date":"2018-07-17T04:37:17.000Z","updated":"2018-11-17T06:22:05.098Z","comments":true,"path":"2018/07/17/在富文本编辑器之外使用quill富文本样式/","link":"","permalink":"rychou.github.io/2018/07/17/在富文本编辑器之外使用quill富文本样式/","excerpt":"在将使用富文本编辑器时遇到了一个这样的问题：如何在富文本编辑器 VueEditor 之外依然能够有原来的样式 一开始的思路是全局引入 quill 的样式文件，因为 VueEditor 是基于 quill 的一个富文本编辑器","text":"在将使用富文本编辑器时遇到了一个这样的问题：如何在富文本编辑器 VueEditor 之外依然能够有原来的样式 一开始的思路是全局引入 quill 的样式文件，因为 VueEditor 是基于 quill 的一个富文本编辑器 123456npm install quill@1.3.6 //先安装quill//在main.js引入样式文件import 'quill/dist/quill.core.css'import 'quill/dist/quill.snow.css'import 'quill/dist/quill.bubble.css' 结果发现依然行不通，通过查看 quill 的样式文件发现 12345678//quill/dist/quill.snow.css.ql-snow .ql-editor pre.ql-syntax &#123; //这是富文本编辑器中代码段（code）的样式 background-color: #23241f; color: #f8f8f2; overflow: visible;&#125; 样式文件是使用了父元素控制的，而通过富文本编辑器生成的 html 字符串中，是没有包含父元素的，因此在要渲染 html 的元素中给他嵌套父元素以及赋予相应的 class 就可以了！ 123456&lt;div class=\"ql-container ql-snow\" style=\"border:none\"&gt; &lt;div class=\"ql-editor\"&gt; &lt;div v-html=\"article.content\"&gt;&lt;/div&gt; //这是渲染html字符串的元素，其余是给他嵌套的父元素 &lt;/div&gt;&lt;/div&gt; 参考链接：https://segmentfault.com/q/1010000012313485","categories":[],"tags":[{"name":"踩坑","slug":"踩坑","permalink":"rychou.github.io/tags/踩坑/"},{"name":"vue","slug":"vue","permalink":"rychou.github.io/tags/vue/"}]},{"title":"发布你的第一个npm包！","slug":"2017-12-6","date":"2017-12-06T12:23:28.000Z","updated":"2017-12-06T15:38:32.345Z","comments":true,"path":"2017/12/06/2017-12-6/","link":"","permalink":"rychou.github.io/2017/12/06/2017-12-6/","excerpt":"1. 新建代码库 比如用的是github，那么在github上面创一个库，库的名字用你想发布的npm包名就好了。 2. clone到本地 3. 在本地库运行npm init 按照提示依次输入信息，如果有不想输入的话直接回车就好了。最终生成的package.json文件内容如下：","text":"1. 新建代码库 比如用的是github，那么在github上面创一个库，库的名字用你想发布的npm包名就好了。 2. clone到本地 3. 在本地库运行npm init 按照提示依次输入信息，如果有不想输入的话直接回车就好了。最终生成的package.json文件内容如下： { &quot;name&quot;: &quot;rycou-test&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;a test&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: { &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; }, &quot;repository&quot;: { &quot;type&quot;: &quot;git&quot;, &quot;url&quot;: &quot;https://git.coding.net/rychouuuu/test-npm-install.git&quot; }, &quot;keywords&quot;: [ &quot;test&quot; ], &quot;author&quot;: &quot;rychou&quot;, &quot;license&quot;: &quot;ISC&quot; } 这里还需要一个入口文件，我这里用的是默认的index.js。在本地库里面新建文件index.js,内容如下： exports.showMsg = function () { console.log(&quot;This is my first module&quot;); }; 然后把本地库git push到远程库。 4. 发布npm包 4.1 首先要在官网注册一个账号,npm注册4.2 如果是第一次登陆的话，要在本地运行npm login，登陆一下。 $npm login Username: (你注册的时候的Username) Email: (你的注册邮箱) 4.3 运行npm publish发布包，发布之后去官网(npm)搜一下你的包是否发布成功。 发布过程中你可能会遇到错误： error 1： 使用cnpm的报错处理方法： 换回npm的镜像 npm config set registry http://registry.npmjs.org //发布之后改回淘宝镜像就好了 npm config set registry https://registry.npm.taobao.org error 2: 邮箱未认证处理方法： 去官网登陆后，会弹出一个是否发送邮箱的认证，点击发邮箱去自己的邮箱点击链接认证，然后再发布就好了 其他错误： 遇到其他错误的话，google查一下。 5. 用自己刚刚发布的包 5.1 在本地新建一个空目录，然后 npm install (你发布的包名) 5.2 新建index.js，内容： var test = require(&apos;你的包名&apos;); test.showMsg(); 5.3 node index.js 5.4 运行结果： This is my first module 恭喜你成功了","categories":[],"tags":[{"name":"npm","slug":"npm","permalink":"rychou.github.io/tags/npm/"}]},{"title":"C++中的引用转化为C语言的指针","slug":"2017-11-27","date":"2017-11-27T13:02:49.000Z","updated":"2017-11-29T15:07:23.279Z","comments":true,"path":"2017/11/27/2017-11-27/","link":"","permalink":"rychou.github.io/2017/11/27/2017-11-27/","excerpt":"C++中引用符号&amp;转化为C语言的指针*的方法最近在写数据结构上机作业时，在网上借鉴(抄)其他人的源代码时，发现有些C语言代码中夹杂着C++的代码，比如这个C++的引用符&amp;就让我很头疼，因为C中没有引用这个概念。其实在C++中是可以完美运行的，但是我又不想在C++里运行，就想怎样让其在C中运行呢。经过百般努力，终于成功了。","text":"C++中引用符号&amp;转化为C语言的指针*的方法最近在写数据结构上机作业时，在网上借鉴(抄)其他人的源代码时，发现有些C语言代码中夹杂着C++的代码，比如这个C++的引用符&amp;就让我很头疼，因为C中没有引用这个概念。其实在C++中是可以完美运行的，但是我又不想在C++里运行，就想怎样让其在C中运行呢。经过百般努力，终于成功了。 typedef struct{ Triple data[MAXSIZE+1]; int rpos[MAXRC+1]; int mu,nu,tu; }RLSMatrix; Status InitSMatrix(RLSMatrix &amp;M,RLSMatrix &amp;N){ int p; for(p=1;p&lt;=M-&gt;tu;p++){ printf(&quot;输入行号：&quot;); scanf(&quot;%d&quot;,&amp;M.data[p].i); printf(&quot;输入列号：&quot;); scanf(&quot;%d&quot;,&amp;M.data[p].j); printf(&quot;输入元素值：&quot;); scanf(&quot;%d&quot;,&amp;M.data[p].e); } ..... } void main(){ RLSMatrix M N; InitSMatrix(M,N); } 上面这段是在C++里的代码，&amp;指的是引用。这代码在C中是跑不起来的，接下来我们做一些改动，让它在C语言跑起来 typedef struct{ Triple data[MAXSIZE+1]; int rpos[MAXRC+1]; int mu,nu,tu; }RLSMatrix; Status InitSMatrix(RLSMatrix *M,RLSMatrix *N){//&amp;换为* int p; for(p=1;p&lt;=M-&gt;tu;p++){ printf(&quot;输入行号：&quot;); scanf(&quot;%d&quot;,&amp;M-&gt;data[p].i);//.换成-&gt; printf(&quot;输入列号：&quot;); scanf(&quot;%d&quot;,&amp;M-&gt;data[p].j);//.换成-&gt; printf(&quot;输入元素值：&quot;); scanf(&quot;%d&quot;,&amp;M-&gt;data[p].e);//.换成-&gt; } ..... } void main(){ RLSMatrix M N; InitSMatrix(&amp;M,&amp;N);//对M,N取址&amp; } 这样我们的代码就可以在C中完美运行啦！！！","categories":[],"tags":[{"name":"C++ C","slug":"C-C","permalink":"rychou.github.io/tags/C-C/"}]},{"title":"学习React的心理路程","slug":"React-Study","date":"2017-11-15T13:52:16.000Z","updated":"2017-11-15T14:06:59.498Z","comments":true,"path":"2017/11/15/React-Study/","link":"","permalink":"rychou.github.io/2017/11/15/React-Study/","excerpt":"","text":"教程链接 React视频教程,密码：8dwj React中文文档 一个网友写的比较好的教程 心路历程一开始直接看老师发过来的一些电子书，看到前面一两章已经初步了解到React的强大，但是不能自己动手实践做一些demo感觉还是很虚，单纯看书也记不住。所以就自己找了一些网课的教程，其中一个就是文章开头贴上去的视频教程。视频里面有5个部分左右吧，每个部分都是直接动手写demo，并且边写边给你解释。刚开始我就是照着视频里的demo一点点写下来（切忌复制黏贴源码，虽然感觉看懂了，但是记忆不深刻），慢慢的就入门了。遇到问题再去网上找，查文档。总结下来我学习的过程就是：看视频—&gt;写视频里的demo—&gt;遇到不懂的问题，网上搜、查文档 最后的建议个人感觉入门一个语言不应该直接硬着头皮去看文档，应该直接动手写demo，写的过程中肯定会遇到很多问题，当你想方设法解决了这些问题之后，自然而然就入门了。(●’◡’●)加油！！！","categories":[],"tags":[]},{"title":"Js中splice()于slice()的区别","slug":"Javascript","date":"2017-11-06T15:48:33.000Z","updated":"2017-11-29T15:07:01.571Z","comments":true,"path":"2017/11/06/Javascript/","link":"","permalink":"rychou.github.io/2017/11/06/Javascript/","excerpt":"splice() 方法与 slice() 方法的作用是不同的，splice() 方法会直接对数组进行修改,可以删除元素，也可以插入元素。而slice()是返回已有数组中的选定元素，可以截取字符串。","text":"splice() 方法与 slice() 方法的作用是不同的，splice() 方法会直接对数组进行修改,可以删除元素，也可以插入元素。而slice()是返回已有数组中的选定元素，可以截取字符串。 splice()语法array.splice(start) array.splice(start, deleteCount) array.splice(start, deleteCount, item1, item2, ...) 示例 var myFish = [&quot;angel&quot;, &quot;clown&quot;, &quot;mandarin&quot;, &quot;surgeon&quot;]; //从第 2 位开始删除 0 个元素，插入 &quot;drum&quot; var removed = myFish.splice(2, 0, &quot;drum&quot;); //运算后的 myFish:[&quot;angel&quot;, &quot;clown&quot;, &quot;drum&quot;, &quot;mandarin&quot;, &quot;surgeon&quot;] //被删除元素数组：[]，没有元素被删除 //从第 3 位开始删除 1 个元素 removed = myFish.splice(3, 1); //运算后的myFish：[&quot;angel&quot;, &quot;clown&quot;, &quot;drum&quot;, &quot;surgeon&quot;] //被删除元素数组：[&quot;mandarin&quot;] //从第 2 位开始删除 1 个元素，然后插入 &quot;trumpet&quot; removed = myFish.splice(2, 1, &quot;trumpet&quot;); //运算后的myFish: [&quot;angel&quot;, &quot;clown&quot;, &quot;trumpet&quot;, &quot;surgeon&quot;] //被删除元素数组：[&quot;drum&quot;] //从第 0 位开始删除 2 个元素，然后插入 &quot;parrot&quot;, &quot;anemone&quot; 和 &quot;blue&quot; removed = myFish.splice(0, 2, &quot;parrot&quot;, &quot;anemone&quot;, &quot;blue&quot;); //运算后的myFish：[&quot;parrot&quot;, &quot;anemone&quot;, &quot;blue&quot;, &quot;trumpet&quot;, &quot;surgeon&quot;] //被删除元素的数组：[&quot;angel&quot;, &quot;clown&quot;] //从第 3 位开始删除 2 个元素 removed = myFish.splice(3, Number.MAX_VALUE); //运算后的myFish: [&quot;parrot&quot;, &quot;anemone&quot;, &quot;blue&quot;] //被删除元素的数组：[&quot;trumpet&quot;, &quot;surgeon&quot;] slice()语法array.slice(start, end) 示例 在数组中读取元素： var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Lemon&quot;, &quot;Apple&quot;, &quot;Mango&quot;]; var citrus = fruits.slice(1,3); 输出： Orange,Lemon 截取字符串 var str=&quot;www.runoob.com!&quot;; document.write(str.slice(4)+&quot;&lt;br&gt;&quot;); // 从第 5 个字符开始截取到末尾 document.write(str.slice(4,10)); // 从第 5 个字符开始截取到第10个字符","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"rychou.github.io/tags/Javascript/"}]},{"title":"给页面添加一个密码验证","slug":"给页面添加一个密码验证","date":"2017-10-18T16:05:29.000Z","updated":"2017-11-29T15:06:32.101Z","comments":true,"path":"2017/10/19/给页面添加一个密码验证/","link":"","permalink":"rychou.github.io/2017/10/19/给页面添加一个密码验证/","excerpt":"文章的密码验证今天写博客的时候想着要些一些日记之类的博客的话，如果没有密码验证那就不叫日记了，所以在网上找了一下方法，下面是我根据别人的改进的js代码,加在文章中可以实现密码验证","text":"文章的密码验证今天写博客的时候想着要些一些日记之类的博客的话，如果没有密码验证那就不叫日记了，所以在网上找了一下方法，下面是我根据别人的改进的js代码,加在文章中可以实现密码验证直接附上源码 &lt;script&gt; while(1){ if(&quot;123456&quot;==prompt(&quot;请输入密码！(123456)&quot;)) { break; } else { alert(&quot;输入错误&quot;); } } &lt;/script&gt; 注意事项： 使用时将该段代码放到文章开头，否则就会不起效果。什么意思呢？看下面图片就知道了。 看到了吧，如果放在文章末尾的话，就会先加载js代码前面的部分，也就是文章内容，所以说，为了防止这种情况发生，得把js代码放在文章开头 不过这个代码还是不完善的，比如说如果你的主题主页不是单纯的列表页的话，那么你在主页就会出现这个密码验证。所以说不完善，博主还在想办法完善中。不过我朋友找到一个插件可以设置密码，下面是我朋友的博客文章https://bababadboy.github.io/2017/10/18/AES%E5%8A%A0%E5%AF%86hexo%E6%96%87%E7%AB%A0/ while(1){ if(\"123456\"==prompt(\"请输入密码！(123456)\")) { break; } else { alert(\"输入错误\"); } }","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"rychou.github.io/tags/hexo/"}]},{"title":"hexo建站的坑","slug":"hexo建站的坑","date":"2017-10-18T15:14:05.000Z","updated":"2017-11-29T15:07:12.748Z","comments":true,"path":"2017/10/18/hexo建站的坑/","link":"","permalink":"rychou.github.io/2017/10/18/hexo建站的坑/","excerpt":"Hexo的安装与使用这是我的第一篇博客，刚开始想弄jekyll的，但是弄了很久也没配置好，干脆直接弄hexo了。接下来讲讲我弄hexo的遇到的一些问题吧。这是一个我看到的一个比较好的教程","text":"Hexo的安装与使用这是我的第一篇博客，刚开始想弄jekyll的，但是弄了很久也没配置好，干脆直接弄hexo了。接下来讲讲我弄hexo的遇到的一些问题吧。这是一个我看到的一个比较好的教程大家在配置好后，在本地运行一般没有问题，但是在推到Github上去的时候， $ hexo deploy Error：Deployer not found: git 我就遇到了这里出错的问题，在网上看了解决办法发现只需要在你的Blog的根目录下运行一下代码 npm install hexo-deployer-git --save 然后再 $ hexo generate $ hexo deploy 然后everything is ok！","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"rychou.github.io/tags/hexo/"}]}]}