{"meta":{"title":"Rychou'blog","subtitle":"Knowledge & Life things!","description":null,"author":"Rychou","url":"rychou.github.io"},"pages":[{"title":"About","date":"2018-11-17T06:45:04.381Z","updated":"2018-11-17T06:45:04.381Z","comments":true,"path":"about/index.html","permalink":"rychou.github.io/about/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-11-17T06:45:04.385Z","updated":"2018-11-17T06:45:04.385Z","comments":true,"path":"tags/index.html","permalink":"rychou.github.io/tags/index.html","excerpt":"","text":""},{"title":"Project","date":"2018-11-17T06:45:04.383Z","updated":"2018-11-17T06:45:04.383Z","comments":true,"path":"project/index.html","permalink":"rychou.github.io/project/index.html","excerpt":"","text":""}],"posts":[{"title":"Js学习笔记：回调函数","slug":"Js学习笔记：回调函数","date":"2018-09-18T06:23:29.000Z","updated":"2018-11-17T10:38:46.134Z","comments":true,"path":"2018/09/18/Js学习笔记：回调函数/","link":"","permalink":"rychou.github.io/2018/09/18/Js学习笔记：回调函数/","excerpt":"A callback is a function that is passed as an argument to another function and is executed after its parent function has completed。 回调函数作为参数传递给另外一个函数，当另外一个函数执行完后再执行这个传递进去的函数（回调函数）。","text":"A callback is a function that is passed as an argument to another function and is executed after its parent function has completed。 回调函数作为参数传递给另外一个函数，当另外一个函数执行完后再执行这个传递进去的函数（回调函数）。 这里我看到一个网上一个很有意思的例子 约会结束后你送你女朋友回家，离别时，你肯定会说：“到家了给我发条信息，我很担心你。” 对不，然后你女朋友回家以后还真给你发了条信息。小伙子，你有戏了。其实这就是一个回调的过程。你留了个参数函数（要求女朋友给你发条信息）给你女朋友，然后你女朋友回家，回家的动作是主函数。她必须先回到家以后，主函数执行完了，再执行传进去的函数，然后你就收到一条信息了。 1234567891011function A(callback) &#123; callback() console.log('1')&#125;function B() &#123; setTimeout(console.log('2'), 3000)&#125;A(B)//输出//1//2 这里回调函数 B 是一个需要等待 3 秒才输出的，然而主函数不必等回调函数 B 执行完毕，可以继续执行自己的代码，然后再去执行回调函数 B。 所以回调函数一般用来做一些耗时的操作，如网络请求等，来实现异步操作。","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"rychou.github.io/tags/Javascript/"},{"name":"踩坑","slug":"踩坑","permalink":"rychou.github.io/tags/踩坑/"},{"name":"回调函数","slug":"回调函数","permalink":"rychou.github.io/tags/回调函数/"}]},{"title":"Mpvue中使用Vant Weapp组件库","slug":"Mpvue中使用Vant Weapp组件库","date":"2018-08-31T06:25:08.000Z","updated":"2018-11-17T10:15:46.670Z","comments":true,"path":"2018/08/31/Mpvue中使用Vant Weapp组件库/","link":"","permalink":"rychou.github.io/2018/08/31/Mpvue中使用Vant Weapp组件库/","excerpt":"一、介绍mpvue-vant记录了我们团队开发中在mpvue中使用Vant Weapp组件库所踩下的坑，在这里分享给大家，让mpvue开发者可以使用vant组件库进行开发，避免踩不必要的坑。","text":"一、介绍mpvue-vant记录了我们团队开发中在mpvue中使用Vant Weapp组件库所踩下的坑，在这里分享给大家，让mpvue开发者可以使用vant组件库进行开发，避免踩不必要的坑。 此教程是在dov-yih一同协助下完成。经过测试，Vant Weapp下所有组件都能够在mpvue中使用 demo 地址 更新日志 二、使用方法 目前 vant 已经支持了npm的方式，但是由于node_modules目录下的代码是不会被编进dist目录下的，所以暂时只能用git方式使用。 克隆 vant 仓库将dist目录下的所有文件复制到你项目的/static/vant/目录下。 1git clone https://github.com/youzan/vant-weapp.git 12// 当然你也可以克隆本仓库代码，本仓库会与`vant`仓库保持同步。直接将`vant`目录复制到`/static`目录下git clone https://github.com/xxxsimons/mpvue-vant.git 引入在需要引入的页面目录下的main.json文件中 12345&#123; \"usingComponents\": &#123; \"van-button\": \"/static/vant/button/index\", &#125;&#125; 使用1&lt;van-button&gt;测试&lt;/van-button&gt; 三、注意事项具体组件 api 文档参考Vant Weapp 1. 使用方式mpvue 和原生小程序的方式有所不同。可以参考mpvue 文档 1.1 数据绑定原生小程序使用方式为 1value=\"&#123;&#123;value&#125;&#125;\" mpvue 使用方式 123v-bind:value=\"value\"//或者:value=\"value\" 1.2 事件监听原生小程序使用方式 1bind:click=\"onClick\" mpvue 使用方式 1@click=\"onClick\" 1.3 vue 中组件引入vant中像notify这种操作反馈类的组件都有两个引入，一是组件的引入，这个在main.json中引入；另一个是方法的引入，需要在vue文件中import引入，值得注意的是，这里的引入不能使用绝对路径，可以用类似于这样的相对路径。 1import Notify from '@/../static/notify/notify' //@是mpvue的一个别名，指向src目录 1.4 获取 event值得注意的是，mpvue中获取event值与原生小程序有所不同。举例： 123onChange(event)&#123; // 获取表单组件filed的值 console.log(event.mp.detail) // 注意加入mp&#125; 2. BUG 及报错处理方法2.1 监听名mpvue 里面无法使用@click-icon这样的监听名,因此如果 API 文档里面有出现这样的监听名，那么需要手动修改源代码。 可以改成驼峰式的监听名。 eg: 我在field组件中就遇到这个问题，我的做法是： 1234567// static/vant/field/index.jsthis.$emit('click-icon');// 修改为:this.$emit('clickIcon'); 2.2 报错一般的报错报错都可以通过一下流程处理。 是否打开了微信开发者工具中的ES6转ES5功能。 仔细检查代码和比对文档，看看是否有使用不当的地方。 重新编译npm run dev或删掉dist目录重新npm run dev 重启或更新微信开发者工具。 若以上流程都走完了，还是无法解决报错，可以通过提交issues的方式，我来帮你解决。 2.2.1 引入组件报错1VM54:1 thirdScriptError sdk uncaught third Error module \"static/vant/notify/index.js\" is not defined 解决办法是：打开小程序开发者工具中的ES6 转 ES5功能. issues/#5 3. 其他组件库目前比较好的组件库有三个，Wux Weapp,iview weapp,Vant Weapp。 这三者都是用原生小程序写的组件库，因此理论上来说，在 mpvue 中都是可以无缝使用的。不同组件库的组件都不一样，有的更丰富，有的逻辑更完善，有的文档更清晰。因此用什么组件，还需要自己取舍。 比如：三者中，唯有Wux Weapp有日历组件，而且它里面还有一些更高级的组件可以使用。 使用方法上，几乎没有差异。值得注意的是，大家复制源代码到自己项目上时，应该复制/dist/目录下的文件。因为这里是经过编译后的。 如果大家使用过程中遇到什么 BUG，可以通过提issues的方式让我知道，大家一起踩坑吧！ 分享一个 Demo作者基于 vant 和 wux 组件库,以及最新的小程序云开发开发的一个小程序。以及总结了mpvue中使用云开发的注意事项，mpvue-cloud 猫叫助手|收录各种猫叫声，帮助与猫咪交流，分享一些养猫的小知识等。","categories":[],"tags":[{"name":"mpvue","slug":"mpvue","permalink":"rychou.github.io/tags/mpvue/"},{"name":"vant","slug":"vant","permalink":"rychou.github.io/tags/vant/"}]},{"title":"小程序输入框闪烁BUG解决方案","slug":"小程序输入框闪烁BUG解决方案","date":"2018-08-30T06:25:08.000Z","updated":"2018-11-17T10:14:37.683Z","comments":true,"path":"2018/08/30/小程序输入框闪烁BUG解决方案/","link":"","permalink":"rychou.github.io/2018/08/30/小程序输入框闪烁BUG解决方案/","excerpt":"前言 本人所说的小程序，都是基于mpvue框架而上的，因此BUG可能是原生小程序的，也有可能是mpvue的。","text":"前言 本人所说的小程序，都是基于mpvue框架而上的，因此BUG可能是原生小程序的，也有可能是mpvue的。 问题描述在小程序input组件中，如果使用v-model进行双向绑定，在输入时会出现光标闪烁的BUG。 原因造成这个 BUG 的原因，是因为在原生小程序input组件上，进行了封装。才导致光标闪烁的问题。 解决方案这里提供了两种解决方案。各有各的优势，请选取合适的方案： 一、弃用v-model,使用@input适用于input组件单纯是用户手动输入的，而没有像授权获取手机号，然后自动填入input组件中。这种需要赋予初始value的情况。即适用于单向绑定，而不是双向绑定。 123456789101112131415161718192021222324252627282930/*** 父组件*/// html&lt;childInput @input=\"onInput\"/&gt; &lt;-- 注意这里不能使用:value=value赋予初始值，否则又会出现闪烁的BUG，因为此时就等同于v-model了// jsimport ChildInput from './ChildInput'export default &#123; components:&#123; ChildInput &#125;, data()&#123; return &#123; value:'' &#125; &#125;, methods()&#123; onInput(e)&#123; this.value = e &#125; &#125;&#125;/*** 子组件 ChildInput*/// html&lt;input @input=\"$emit('input',$event)\"/&gt; 二、不封装input组件，直接使用v-model这种情况就是可以直接双向绑定的了。具体原因还不清楚，可能是本身原生小程序的 BUG。 123456789101112131415/*** 父组件,不使用封装的子组件，直接使用原生组件。*/// html&lt;input v-model=\"value\"/&gt;// jsexport default &#123; data()&#123; return &#123; value:'' &#125; &#125;&#125;","categories":[],"tags":[{"name":"小程序","slug":"小程序","permalink":"rychou.github.io/tags/小程序/"}]},{"title":"小程序分享功能报错问题解决方案","slug":"小程序分享功能报错问题解决方案","date":"2018-08-30T06:25:08.000Z","updated":"2018-11-17T10:13:55.214Z","comments":true,"path":"2018/08/30/小程序分享功能报错问题解决方案/","link":"","permalink":"rychou.github.io/2018/08/30/小程序分享功能报错问题解决方案/","excerpt":"报错信息12345678910111213thirdScriptErrorCannot read property 'apply' of null;at pages/client/home/main page onShareAppMessage functionTypeError: Cannot read property 'apply' of null at t.l (http://127.0.0.1:62595/appservice/__dev__/WAService.js:18:30625) at dn (http://127.0.0.1:62595/appservice/__dev__/WAService.js:20:2360) at Function.pn (http://127.0.0.1:62595/appservice/__dev__/WAService.js:20:3321) at http://127.0.0.1:62595/appservice/__dev__/WAService.js:19:1368 at http://127.0.0.1:62595/appservice/__dev__/WAService.js:20:4179 at n (http://127.0.0.1:62595/appservice/__dev__/WAService.js:6:8644) at a (http://127.0.0.1:62595/appservice/appservice?t=1535626735316:3056:9566) at e.registerCallback (http://127.0.0.1:62595/appservice/appservice?t=1535626735316:3056:9753) at n.forEach (http://127.0.0.1:62595/appservice/appservice?t=1535626735316:3056:5638) at Array.forEach (&lt;anonymous&gt;)","text":"报错信息12345678910111213thirdScriptErrorCannot read property 'apply' of null;at pages/client/home/main page onShareAppMessage functionTypeError: Cannot read property 'apply' of null at t.l (http://127.0.0.1:62595/appservice/__dev__/WAService.js:18:30625) at dn (http://127.0.0.1:62595/appservice/__dev__/WAService.js:20:2360) at Function.pn (http://127.0.0.1:62595/appservice/__dev__/WAService.js:20:3321) at http://127.0.0.1:62595/appservice/__dev__/WAService.js:19:1368 at http://127.0.0.1:62595/appservice/__dev__/WAService.js:20:4179 at n (http://127.0.0.1:62595/appservice/__dev__/WAService.js:6:8644) at a (http://127.0.0.1:62595/appservice/appservice?t=1535626735316:3056:9566) at e.registerCallback (http://127.0.0.1:62595/appservice/appservice?t=1535626735316:3056:9753) at n.forEach (http://127.0.0.1:62595/appservice/appservice?t=1535626735316:3056:5638) at Array.forEach (&lt;anonymous&gt;) 原因这是因为你将onShareAppMessage()这个页面级的方法写到组件中导致的错误，解决办法就是将其写到页面内。","categories":[],"tags":[{"name":"小程序","slug":"小程序","permalink":"rychou.github.io/tags/小程序/"}]},{"title":"为你的博客添加目录索引","slug":"为你的博客添加目录索引","date":"2018-08-21T06:25:08.000Z","updated":"2018-11-17T10:08:31.677Z","comments":true,"path":"2018/08/21/为你的博客添加目录索引/","link":"","permalink":"rychou.github.io/2018/08/21/为你的博客添加目录索引/","excerpt":"一、前言演示图例","text":"一、前言演示图例 需求这个目录索引应该包含以下功能： 点击目录项跳转到对应锚点 屏幕滚动时，对应目录项样式变化 话不多说，开始干！ 二、点击目录项跳转到对应锚点hash 模式的路由下的锚点说到文章的目录索引，首先想到的就是锚点了。然而在hash模式的路由下，如果使用原始的锚点方案会造成下面这样的问题。 123456// 文章url链接,hash模式下www.rychou.xyz/#/article/70// 如果采用传统的锚点方式，比如有个锚点：anchor-1，点击之后，url会变成www.rychou.xyz/#anchor-1 很明显，在hash模式下，就不能采用这种方式锚点了。我采用了自定义锚点的方式。 参考：vue2.0 中怎么做锚点定位 添加锚点和初始化目录的数据结构方法有了，然后就是怎么给文章加添加锚点了。 我采用了遍历 dom 树，然后找到文章的h1标签（暂时只对h1标签建立索引），为其添加id的方式建立索引。 1234567891011// 初始化文章锚点和目录数据结构getDirectories() &#123; let directories = document.querySelectorAll(\".article-content h1\"); //找到属于文章内容的h1标签 directories.forEach((element, index) =&gt; &#123; element.id = \"anchor-\" + index;//添加id this.directories.push(&#123; title: element.innerText, //h1标签文本内容 offsetTop: element.offsetTop, //记录当前h1标签的偏移量，方便后面计算滚动距离。 isActive: false //是否被选中 &#125;); &#125;); 实现点击跳转到对应锚点123456789101112&lt;div v-for=\"(item,index) in directories\" :key=\"index\"&gt; &lt;a href=\"javascript:void(0)\" @click=\"goAnchor(index)\" &gt; &#123;&#123;item.title&#125;&#125; &lt;/a&gt;&lt;/div&gt;methods:&#123; goAnchor(index) &#123; document.documentElement.scrollTop = this.directories[index].offsetTop; &#125;,&#125; 三、屏幕滚动时，对应目录项样式变化注意我们前面初始化目录数据结构中，包含了一个叫isActive的状态位，就是根据这个状态位来进行相应的渲染 动态绑定class12345678910&lt;div class=\"directories-container\"&gt; &lt;div class=\"directories-list\"&gt; &lt;h2&gt;目录&lt;/h2&gt; &lt;div :class=\"&#123;'highlight-title':item.isActive&#125;\" v-for=\"(item,index) in directories\" :key=\"index\" style=\"padding: 5px 12px;\"&gt; &lt;a href=\"javascript:void(0)\" @click=\"goAnchor(index)\" &gt; &#123;&#123;item.title&#125;&#125; &lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 添加滚动监听12345678// 挂载页面时，添加滚动监听mounted() &#123; window.addEventListener(\"scroll\", this.handleScroll); &#125;,// 退出页面时，应该取消监听destroyed() &#123; window.removeEventListener(\"scroll\", this.handleScroll);&#125;, 计算状态位isActive12345678910111213handleScroll(e) &#123; let scrollTop = document.documentElement.scrollTop //当前滚动距离 this.directories.forEach((element,index)=&gt;&#123; if((scrollTop)&gt;=element.offsetTop)&#123;//当前滚动距离大于某一目录项时。 for(let i=0;i&lt;index;i++)&#123; this.directories[i].isActive = false //同一时刻，只能有一个目录项的状态位为Active，即此时其他目录项的isActive = false &#125; element.isActive = true; //将对应的目录项状态位置为true &#125;else&#123; element.isActive = false; &#125; &#125;)&#125; css 样式12345678910111213141516171819202122232425262728// scss.directories-container &#123; width: 15vw; transition: all 0.5s; margin-left: 10px; .highlight-title &#123; border-left: 3px solid rgb(15, 105, 223); background-color: rgb(243, 243, 243); z-index: -1; a&#123; color: rgb(15, 105, 223) &#125; &#125; .directories-list &#123; position: -webkit-sticky; position: sticky; top: 0; word-wrap: break-word; background-color: #fff; border-left: 1px solid rgb(236, 236, 236); z-index: 999; a &#123; &amp;:hover &#123; text-decoration: underline; &#125; &#125; &#125;&#125;","categories":[],"tags":[{"name":"目录","slug":"目录","permalink":"rychou.github.io/tags/目录/"}]},{"title":"用gitalk给你的博客添加评论服务","slug":"用gitalk给你的博客添加评论服务","date":"2018-08-18T06:28:03.000Z","updated":"2018-11-17T10:06:49.978Z","comments":true,"path":"2018/08/18/用gitalk给你的博客添加评论服务/","link":"","permalink":"rychou.github.io/2018/08/18/用gitalk给你的博客添加评论服务/","excerpt":"一、前言不像 hexo、jekyll 等，为了学习，我的博客是用vue和nodejs搭建出来的。支持在线编辑和 markdown 渲染等功能。 大家如果感兴趣可以看我的博客地址 最近给自己的博客添加了评论服务，用到的评论服务是Gitalk，它是基于github issue搭建出来的评论系统。废话不多说，接下来说说如何使用。","text":"一、前言不像 hexo、jekyll 等，为了学习，我的博客是用vue和nodejs搭建出来的。支持在线编辑和 markdown 渲染等功能。 大家如果感兴趣可以看我的博客地址 最近给自己的博客添加了评论服务，用到的评论服务是Gitalk，它是基于github issue搭建出来的评论系统。废话不多说，接下来说说如何使用。 二、必要的准备在 Github 创建一个用来存放评论的仓库当然你也可以直接用你博客所在的仓库，因为我的博客部署到了coding pages，所以我单独创建了一个仓库用来存放评论。 注册一个Github OAuth application没有的可以点这里申请 注册成功后，记录下你的clientID和clientSecret。 三、安装有两种方式安装(CDN 和 npm)，大家可自行选择。 1. CDN1234567&lt;link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css\"&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js\"&gt;&lt;/script&gt;&lt;!-- or --&gt;&lt;link rel=\"stylesheet\" href=\"https://unpkg.com/gitalk/dist/gitalk.css\"&gt;&lt;script src=\"https://unpkg.com/gitalk/dist/gitalk.min.js\"&gt;&lt;/script&gt; 2. npm1npm i --save gitalk 四、使用考虑到vue的生命周期等，使用方法上和官方文档给出来的是需要做略微的调整的。 引入 gitalk123456//在index.html页面中CDN引入&lt;link rel=\"stylesheet\" href=\"https://unpkg.com/gitalk/dist/gitalk.css\"&gt;&lt;script src=\"https://unpkg.com/gitalk/dist/gitalk.min.js\"&gt;//在vue中importimport Gitalk from 'gitalk' 初始化 Gitalk 实例123456789101112131415export default &#123; data()&#123; return&#123; gitalk: new Gitalk(&#123; clientID: \"你的clientID\", clientSecret: \"你的clientSecret\", repo: \"刚刚创建的项目名\", owner: \"github用户名\", admin: [\"github用户名\"], id: window.location.hash, // 默认为pathname,如果你也是像我这样用vue搭建的，我建议使用hash，原因具体后面会讨论到。 distractionFreeMode: false // Facebook-like distraction free mode &#125;) &#125; &#125;&#125; 在恰当的位置添加标签,用来渲染 Gitalk 组件。1&lt;div id=\"gitalk-container\"&gt;&lt;/div&gt; 渲染123mounted()&#123; this.gitalk.render(\"gitalk-container\");&#125; 五、注意事项id 的设置这个 id 是用来唯一区分页面的，也就是你不同的文章肯定有不同的评论数据，Gitalk要通过这个 id 来区分是哪个页面，然后在你的github仓库创建相应的issue来存放当页评论数据，id默认值是window.location.pathname 但是默认的只适用于采用history模式的路由，但对于vue-router这种默认采用hash模式的就不行了。 举个例子 123456789//在history模式下，路由URL如下格式www.rychou.xyz/article/69window.location.pathname;// 值是 /article/69//在hash模式下，路由变成这样了www.rychou.xyz/#/article/69window.location.pathname; // 值是 / 此时，在hash模式下id就不具有唯一性了。 建议使用window.location.hash，此时的值是#/aticle/69,具有唯一性。 当然你也可以设置vue-router为history模式，但是这会有一个刷新页面出现 404 的 BUG，解决办法参考官方文档 不使用类似的评论服务Gitment的原因我也试过用Gitment，也成功了，但是有一个非常令人不爽的地方，就是每一篇文章都需要手动初始化(创建相应 issue)，因此我还是用了Gitalk,它会根据你的配置，自动帮你初始化。 六、最后有问题的同学们，欢迎来原文下方提问，同时也相当于帮我测试一下评论服务了。 参考链接： Gitalk Gitment 官方文档- vue-router History 模式","categories":[],"tags":[{"name":"Gitalk","slug":"Gitalk","permalink":"rychou.github.io/tags/Gitalk/"}]},{"title":"用shelljs实现前端部署自动化","slug":"用shelljs实现前端部署自动化","date":"2018-08-17T06:28:03.000Z","updated":"2018-11-17T10:06:53.923Z","comments":true,"path":"2018/08/17/用shelljs实现前端部署自动化/","link":"","permalink":"rychou.github.io/2018/08/17/用shelljs实现前端部署自动化/","excerpt":"一、场景在前端开发过程中，你肯定经常使用到以下等命令： 1234npm run buildgit add .git commit -m 'commit'git push","text":"一、场景在前端开发过程中，你肯定经常使用到以下等命令： 1234npm run buildgit add .git commit -m 'commit'git push 本人在用vue-cli写我的个人博客时，将其部署到coding pages上。不用github pages的原因纯粹是因为慢。。。每一次部署，都要将上面的命令敲一遍，实在令我很痛苦。如果能用一条命令执行以上所有任务，那就爽多了。 话不多说，说干就干。 二、Shelljs这个库能够让我们在js文件中执行 shell 命令，具体可以看文档。 安装1npm install [-g] shelljs 有两种使用方式，一种是全局模式(对应全局安装),一种是局部模式。看下面的使用案例就知道两者区别。 三、使用在根目录下新建文件shell.js，内容如下： 1234567891011121314151617//局部模式var shell = require('shelljs');//全局模式下，就不需要用shell开头了。//require('shelljs/global');if (shell.exec('npm run build').code !== 0) &#123;//执行npm run build 命令 shell.echo('Error: Git commit failed'); shell.exit(1);&#125;//由于我的用另外一个仓库存放dist目录，所以这里要将文件增量复制到目标目录。并切换到对应目录。shell.cp ('-r', './dist/*', '../../Rychou');shell.cd('../../Rychou');shell.exec('git add .');shell.exec(\"git commit -m 'autocommit'\")shell.exec('git push') 这时在根目录下执行node shell.js就可以了 这里只是最简单的使用案例。 四、再让它更方便些在package.json中加入： 123\"script\":&#123;+ \"push\":\"node ./shell.js\"&#125; 在根目录下执行npm run push就搞定了。 参考链接：Shelljs","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"rychou.github.io/tags/Javascript/"},{"name":"前端自动化","slug":"前端自动化","permalink":"rychou.github.io/tags/前端自动化/"}]},{"title":"Js学习笔记：apply与call","slug":"Js学习笔记：apply与call","date":"2018-08-15T06:32:20.000Z","updated":"2018-11-17T10:04:29.719Z","comments":true,"path":"2018/08/15/Js学习笔记：apply与call/","link":"","permalink":"rychou.github.io/2018/08/15/Js学习笔记：apply与call/","excerpt":"一、apply 与 call 的区别相同点：“可以让一个对象调用另一个对象的方法” 不同点： apply 最多只能传入两个参数，第一个为对象，第二个为数组 call 能传入多个参数，第一个为对象，其后为 n 个参数列表","text":"一、apply 与 call 的区别相同点：“可以让一个对象调用另一个对象的方法” 不同点： apply 最多只能传入两个参数，第一个为对象，第二个为数组 call 能传入多个参数，第一个为对象，其后为 n 个参数列表 实际上，apply 和 call 实现的功能是一样的，只是传入的参数不同而已。 示例: 12345678910111213function add(a,b)&#123; return a+b;&#125;function sub(a,b)&#123; return a-b;&#125;var a1 = add.apply(sub,[4,2]); //sub调用add的方法var a2 = sub.apply(add,[4,2]);alert(a1); //6alert(a2); //2/*call的用法*/var a1 = add.call(sub,4,2); apply 的一些使用技巧 配合Math.max()计算数组最大值 因为Math.max()不支持数组的方式，只能Math.max(a,b,c....)。根据 apply 的特点来实现这一功能，Math.max.apply(null,[1,2,3]),因为没有新的对象调用 Math 的 max 方法，所以只是传入 null 来利用 apply 的特性帮助进行计算而已。 apply 会将数组中的每个元素一个个传入给 Math.max()。也就相当于Math.max.call(null,1,2,3) 同理可以用Math.min.apply(null,[1,2,3])计算数组最小值 配合 Array.prototype.push 实现两个数组合并 数组的 push 方法是不能 push 数组的，但是可以同时 push 多个元素，因此可以利用 apply 的特性 1234var a = [1,2,3];var b = [4,5,6];Array.prototype.push.apply(a,b);//apply会将为b中每一个元素执行一次push方法。返回值是push后数组a的长度 参考链接:apply()与 call()的区别 二、Object.prototype.toString.call()进行类型检验首先来看一个问题，用 typeof 来检验类型有什么缺点呢？ 答案是 typeof 无法准确地检验对象类型。 12typeof null //objecttypeof [] //object null的类型是object，这是由于历史原因造成的。1995 年的 JavaScript 语言第一版，只设计了五种数据类型（对象、整数、浮点数、字符串和布尔值），没考虑null，只把它当作object的一种特殊值。后来null独立出来，作为一种单独的数据类型，为了兼容以前的代码，typeof null返回object就没法改变了。 比较好的方式就是用 Object.prototype.toString.call()来进行检验。 12345678910var a = &#123;&#125;;var b = [];var c = 1;Object.prototype.toString.call(a);//[object,Object]Object.prototype.toString.call(b);//[object,Array]Object.prototype.toString.call(c);//[object,Number]//判断a是否是对象类型Object.prototype.toString.call(a) === \"[object,Object]\" 注意：使用 obj.toString()是不能得到类型的。原因：Array,Function 等类型作为 Object 的实例，都重写的了 toString 方法。因此在调用时，是调用了重写后的方法，而不是原型链上的 toString()方法 123456var arr=[1,2,3];console.log(Array.prototype.hasOwnProperty(\"toString\"));//trueconsole.log(arr.toString());//1,2,3delete Array.prototype.toString;//delete操作符可以删除实例属性console.log(Array.prototype.hasOwnProperty(\"toString\"));//falseconsole.log(arr.toString());//\"[object Array]\" 删除了重写的方法后，使用 obj.toString()也就相当于调用原型链的方法了，即 Object.prototype.toString.call() 参考链接: 为什么用 Object.prototype.toString.call(obj)检测对象类型? 深入理解 Object.prototype.toString.call()","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"rychou.github.io/tags/Javascript/"}]},{"title":"小程序实现长按录音，上划取消发送","slug":"小程序实现长按录音，上划取消发送","date":"2018-07-23T06:28:03.000Z","updated":"2018-11-17T06:28:37.626Z","comments":true,"path":"2018/07/23/小程序实现长按录音，上划取消发送/","link":"","permalink":"rychou.github.io/2018/07/23/小程序实现长按录音，上划取消发送/","excerpt":"最近在使用 mpvue 开发小程序，需要用到录音功能，于是打算参照微信的录音方案：”长按录音松开发送，上划取消发送”。在网上找了一圈都没发现相似的案例，没办法只能自己实现。 下面讲解只贴上关键代码","text":"最近在使用 mpvue 开发小程序，需要用到录音功能，于是打算参照微信的录音方案：”长按录音松开发送，上划取消发送”。在网上找了一圈都没发现相似的案例，没办法只能自己实现。 下面讲解只贴上关键代码 1. html 部分。微信小程序事件接口： 类型 触发条件 touchstart 手指触摸动作开始 touchmove 手指触摸后移动 touchend 手指触摸动作结束 longpress 手指触摸后，超过 350ms 再离开，如果指定了事件回调函数并触发了这个事件，tap 事件将不被触发 longtap 手指触摸后，超过 350ms 再离开（推荐使用 longpress 事件代替） 分析:长按录音需要 longpress 事件，松开发送需要 touchend 事件，上滑取消发送需要 touchmove 事件。由此可有以下 html 代码 //html部分 class部分只是控制样式 与功能无关 &lt;div class=&quot;input weui-grid&quot; hover-class=&quot;weui-grid_active&quot; :class=&quot;record.type&quot; @longpress=&quot;handleRecordStart&quot; @touchmove=&quot;handleTouchMove&quot; @touchend=&quot;handleRecordStop&quot;&gt; &lt;image class=&quot;weui-grid__icon&quot; :src=&quot;record.iconPath&quot;/&gt; &lt;div class=&quot;weui-grid__label&quot;&gt;{{record.text}}&lt;/div&gt; &lt;/div&gt; 2. JS 部分2.1. 首先定义录音的数据结构：旧版的小程序录音接口 wx.startRecord 和 wx.stopRecord 在 1.6.0 版本后不再维护了，所以使用其建议的wx.getRecordManager接口。 注意:使用 wx.getRecordManager 接口的话,应调用相应的音频控制接口wx.createInnerAudioContext()来播放和控制录音. data(){ record: { text: &quot;长按录音&quot;, type: &quot;record&quot;, iconPath: require(&quot;@/../static/icons/record.png&quot;), handler: this.handleRecordStart }, //与录音相关的数据结构 recorderManager: wx.getRecorderManager(), //录音管理上下文 startPoint: {}, //记录长按录音开始点信息,用于后面计算滑动距离。 sendLock: true, //发送锁，当为true时上锁，false时解锁发送 }, 2.2. 监听录音 stoponLoad(){ this.recorderManager.onStop(res =&gt; { if (this.sendLock) { //上锁不发送 } else {//解锁发送，发送网络请求 if (res.duration &lt; 1000) wx.showToast({ title: &quot;录音时间太短&quot;, icon: &quot;none&quot;, duration: 1000 }); else this.contents = [...this.contents,{ type: &quot;record&quot;, content: res }];//contents是存储录音结束后的数据结构,用于渲染. } }); } 2.3. 长按录音方法在这个方法中需要做的事: 记录长按的点信息,用于后面计算手指滑动的距离,实现上滑取消发送. 做一些界面样式的控制. 开始录音 handleRecordStart(e) { //longpress时触发 this.startPoint = e.touches[0];//记录长按时开始点信息，后面用于计算上划取消时手指滑动的距离。 this.record = {//修改录音数据结构，此时录音按钮样式会发生变化。 text: &quot;松开发送&quot;, type: &quot;recording&quot;, iconPath: require(&quot;@/../static/icons/recording.png&quot;), handler: this.handleRecordStart }; this.recorderManager.start();//开始录音 wx.showToast({ title: &quot;正在录音，上划取消发送&quot;, icon: &quot;none&quot;, duration: 60000//先定义个60秒，后面可以手动调用wx.hideToast()隐藏 }); this.sendLock = false;//长按时是不上锁的。 }, 2.4. 松开发送在这个方法中需要做的事: 做一些样式的控制. 结束录音. handleRecordStop() { // touchend(手指松开)时触发 this.record = {//复原在start方法中修改的录音的数据结构 text: &quot;长按录音&quot;, type: &quot;record&quot;, iconPath: require(&quot;@/../static/icons/record.png&quot;), handler: this.handleRecordStart }; wx.hideToast();//结束录音、隐藏Toast提示框 this.recorderManager.stop();//结束录音 } 2.5. 上划取消发送在这个方法中需要做的事: 计算手指上滑的距离 根据距离判断是否需要取消发送 如果取消发送,最重要的是 this.sendLock = true,上锁不发送 handleTouchMove(e) { //touchmove时触发 var moveLenght = e.touches[e.touches.length - 1].clientY - this.startPoint.clientY; //移动距离 if (Math.abs(moveLenght) &gt; 50) { wx.showToast({ title: &quot;松开手指,取消发送&quot;, icon: &quot;none&quot;, duration: 60000 }); this.sendLock = true;//触发了上滑取消发送，上锁 } else { wx.showToast({ title: &quot;正在录音，上划取消发送&quot;, icon: &quot;none&quot;, duration: 60000 }); this.sendLock = false;//上划距离不足，依然可以发送，不上锁 } }, } 2.6. 演示 GIF","categories":[],"tags":[{"name":"小程序","slug":"小程序","permalink":"rychou.github.io/tags/小程序/"},{"name":"录音","slug":"录音","permalink":"rychou.github.io/tags/录音/"},{"name":"mpvue","slug":"mpvue","permalink":"rychou.github.io/tags/mpvue/"}]},{"title":"vue和小程序踩坑指南","slug":"vue和小程序踩坑指南","date":"2018-07-19T06:25:08.000Z","updated":"2018-11-17T06:27:12.610Z","comments":true,"path":"2018/07/19/vue和小程序踩坑指南/","link":"","permalink":"rychou.github.io/2018/07/19/vue和小程序踩坑指南/","excerpt":"一、参考文档 小程序官方 Api 文档 mpvue 官方文档 vue 官方文档","text":"一、参考文档 小程序官方 Api 文档 mpvue 官方文档 vue 官方文档 二、工具篇1. VSCode 插件 Eslint 格式化代码插件，在写代码时提示格式以及保存代码时自动格式化代码。配置教程 mpvue snippets 小程序和 mpvue 代码提示 Vetur Vue 开发工具 2. normalize 前端解析 Json APIa:{ 1:{ type:&#39;&#39;, id:&#39;&#39; } } 对于这种对象的key为数字的，然而并不知道数字是啥，可以使用a[Object.keys(a)[0]]来访问第一个元素 3. mpvue-router-patch在 mpvue 中使用 vue-router 的写法4. flyio 发起网络请求5. 封装小程序 API，实现异步调用// WXP.js // 核心 function f (func, obj) { return new Promise((resolve, reject) =&gt; { func({ ...obj, success: resolve, fail: reject }) }) } export default { // 获取认证 code login: obj =&gt; f(wx.login, obj), } //使用 import WXP from &#39;WXP&#39; WXP.login({}) .then(res=&gt;{}) .catch(err=&gt;{}) 6. Promise 实现 finally.// 安装 npm i --save promise.prototype.finally // main.js引入 require(&#39;promise.prototype.finally&#39;).shim(); // 使用 promise()//某个异步操作 .then() .catch() .finally() 三、踩坑1.修改 v-html 渲染的标签样式不生效的问题产生原因：在中加了 scoped 属性，这个属性的作用是让样式私有化（只在本组件生效）。而使用了 v-html 之后，其实际是被当成子组件了，因此导致样式不生效 解决办法：去掉中的 scoped &lt;template&gt; &lt;div v-html=&quot;htmlString&quot;&gt;&lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default{ data(){ return(){ htmlString:&#39;&#39;//要渲染的html字符串 } } } &lt;/script&gt; &lt;style lang=&quot;scss&quot;&gt;//去掉scoped &lt;/style&gt; 2. 如何在 vue 中使用 hightlight.js 高亮你的代码安装 highlight.jsnpm install highlight.js --save 在顶层 main.js 中加入以下代码段import hljs from &#39;highlight.js&#39; import &#39;highlight.js/styles/monokai.css&#39;//样式文件 //vue自定义指令，检索所有的code标签进行高亮 Vue.directive(&#39;highlight&#39;,function (el) { let blocks = el.querySelectorAll(&#39;code&#39;); blocks.forEach((block)=&gt;{ hljs.highlightBlock(block) }) }) 在你文章的顶层标签加入自定义指令 v-highlight&lt;div class=&quot;article-body&quot; v-html=&quot;compileMarkdown&quot; v-highlight&gt;&lt;/div&gt; 3. 不要在 computed 内使用 split()方法4.wx.showToast({title:’text’,image:’/state/xx.png’})需要用绝对路径5. &lt;scroll-view&gt;&lt;/scroll-view&gt;组件5.1. 如若需要竖向滚动，则需要设置固定高度，并且单位不能为 rpx（设置成 rpx 会有显示的问题，显示不全）&lt;scroll-view :scroll-y=&quot;true&quot; :style=&quot;{&#39;height&#39;: scrollHeight+&#39;px;&#39;,&#39;padding-top&#39;:&#39;100rpx&#39;}&quot; //切不要设置成rpx，否则会出现显示不全的bug :enable-back-to-top=&quot;true&quot; @scrolltolower=&quot;loadData&quot; &gt; ... &lt;/scroll-view&gt; //获取屏幕高度 wx.getSystemInfo({ success: res =&gt; { this.scrollHeight = parseInt(res.windowHeight); } }); 5.2.使用&lt;scroll-view&gt;&lt;/scroll-view&gt;组件与onPullDownRefresh不能同时使用参考：微信小程序—下拉刷新上拉加载 6. 录音6.1. 格式问题导致录音无法播放。小程序推荐使用的录音管理上下文wx.getRecorderManager()支持的录音格式有两种:aac/mp3。如果不指定格式，在安卓端录音的文件格式是 m4a 的，会导致无法播放。 所以需要在录音时手动设置格式为mp3格式，aac会有播放不全的 BUG this.recordManager.start({ format: &#39;mp3&#39; // })","categories":[],"tags":[{"name":"踩坑","slug":"踩坑","permalink":"rychou.github.io/tags/踩坑/"},{"name":"小程序","slug":"小程序","permalink":"rychou.github.io/tags/小程序/"},{"name":"Vue","slug":"Vue","permalink":"rychou.github.io/tags/Vue/"}]},{"title":"小程序Tabs懒加载","slug":"小程序Tabs懒加载","date":"2018-07-17T06:26:31.000Z","updated":"2018-11-17T06:27:31.564Z","comments":true,"path":"2018/07/17/小程序Tabs懒加载/","link":"","permalink":"rychou.github.io/2018/07/17/小程序Tabs懒加载/","excerpt":"小程序用 mpvue 编写 v-if 和:hidden 的区别这两种方式都可以用来控制组件的显示与隐藏，但他们实现原理上有所不同。","text":"小程序用 mpvue 编写 v-if 和:hidden 的区别这两种方式都可以用来控制组件的显示与隐藏，但他们实现原理上有所不同。 v-if：这是条件渲染，只有当其为 true 时，才会渲染出来:hidden：这只是控制组件的显示与隐藏，会将所有组件都在开始的时候全部加载，只是有的组件没有显示而已。 v-if 有更高的切换消耗（切换会有旧组件销毁和新组件挂载），而 hidden 有更高的初始渲染消耗（在初始就挂载所有组件）。所以 hidden 更适合用于频繁切换 使用 hidden 实现懒加载 在父组件用 hidden 控制组件隐藏显示 index.vue//父组件 ---------------------------- ... &lt;template&gt; &lt;div class=&quot;weui-tab__panel&quot;&gt; &lt;div class=&quot;weui-tab__content&quot; :hidden=&quot;hiddens[index]&quot; v-for=&quot;(tab,index) in tabs&quot; :key=&quot;index&quot; &gt;//在tab内容组件外面一层用hidden控制组件隐藏 &lt;list-delegate :hidden=&quot;hiddens[index]&quot;/&gt;//这里将hidden属性传入tab内容子组件内部，其内部根据hidden进行相关的控制。 &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; ... &lt;script&gt; export default{ data(){ return(){ tabs: [&quot;推荐&quot;, &quot;热门&quot;, &quot;我的&quot;], activeIndex: 0, } } computed: { hiddens(){ return [this.activeIndex!=0,this.activeIndex!=1,this.activeIndex!=2]//hiddens数组，计算当前hidden的tab，一共有3个tab } ........ } &lt;/script&gt; -------------------------------------- 2.在 tab 内容子组件用传入的 hidden 属性进行相关的控制","categories":[],"tags":[{"name":"踩坑","slug":"踩坑","permalink":"rychou.github.io/tags/踩坑/"},{"name":"小程序","slug":"小程序","permalink":"rychou.github.io/tags/小程序/"}]},{"title":"在富文本编辑器之外使用quill富文本样式","slug":"在富文本编辑器之外使用quill富文本样式","date":"2018-07-17T04:37:17.000Z","updated":"2018-11-17T06:22:05.098Z","comments":true,"path":"2018/07/17/在富文本编辑器之外使用quill富文本样式/","link":"","permalink":"rychou.github.io/2018/07/17/在富文本编辑器之外使用quill富文本样式/","excerpt":"在将使用富文本编辑器时遇到了一个这样的问题：如何在富文本编辑器 VueEditor 之外依然能够有原来的样式 一开始的思路是全局引入 quill 的样式文件，因为 VueEditor 是基于 quill 的一个富文本编辑器","text":"在将使用富文本编辑器时遇到了一个这样的问题：如何在富文本编辑器 VueEditor 之外依然能够有原来的样式 一开始的思路是全局引入 quill 的样式文件，因为 VueEditor 是基于 quill 的一个富文本编辑器 npm install quill@1.3.6 //先安装quill //在main.js引入样式文件 import &#39;quill/dist/quill.core.css&#39; import &#39;quill/dist/quill.snow.css&#39; import &#39;quill/dist/quill.bubble.css&#39; 结果发现依然行不通，通过查看 quill 的样式文件发现 //quill/dist/quill.snow.css .ql-snow .ql-editor pre.ql-syntax { //这是富文本编辑器中代码段（code）的样式 background-color: #23241f; color: #f8f8f2; overflow: visible; } 样式文件是使用了父元素控制的，而通过富文本编辑器生成的 html 字符串中，是没有包含父元素的，因此在要渲染 html 的元素中给他嵌套父元素以及赋予相应的 class 就可以了！ &lt;div class=&quot;ql-container ql-snow&quot; style=&quot;border:none&quot;&gt; &lt;div class=&quot;ql-editor&quot;&gt; &lt;div v-html=&quot;article.content&quot;&gt;&lt;/div&gt; //这是渲染html字符串的元素，其余是给他嵌套的父元素 &lt;/div&gt; &lt;/div&gt; 参考链接：https://segmentfault.com/q/1010000012313485","categories":[],"tags":[{"name":"踩坑","slug":"踩坑","permalink":"rychou.github.io/tags/踩坑/"},{"name":"vue","slug":"vue","permalink":"rychou.github.io/tags/vue/"}]},{"title":"发布你的第一个npm包！","slug":"2017-12-6","date":"2017-12-06T12:23:28.000Z","updated":"2017-12-06T15:38:32.345Z","comments":true,"path":"2017/12/06/2017-12-6/","link":"","permalink":"rychou.github.io/2017/12/06/2017-12-6/","excerpt":"1. 新建代码库 比如用的是github，那么在github上面创一个库，库的名字用你想发布的npm包名就好了。 2. clone到本地 3. 在本地库运行npm init 按照提示依次输入信息，如果有不想输入的话直接回车就好了。最终生成的package.json文件内容如下：","text":"1. 新建代码库 比如用的是github，那么在github上面创一个库，库的名字用你想发布的npm包名就好了。 2. clone到本地 3. 在本地库运行npm init 按照提示依次输入信息，如果有不想输入的话直接回车就好了。最终生成的package.json文件内容如下： { &quot;name&quot;: &quot;rycou-test&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;a test&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: { &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; }, &quot;repository&quot;: { &quot;type&quot;: &quot;git&quot;, &quot;url&quot;: &quot;https://git.coding.net/rychouuuu/test-npm-install.git&quot; }, &quot;keywords&quot;: [ &quot;test&quot; ], &quot;author&quot;: &quot;rychou&quot;, &quot;license&quot;: &quot;ISC&quot; } 这里还需要一个入口文件，我这里用的是默认的index.js。在本地库里面新建文件index.js,内容如下： exports.showMsg = function () { console.log(&quot;This is my first module&quot;); }; 然后把本地库git push到远程库。 4. 发布npm包 4.1 首先要在官网注册一个账号,npm注册4.2 如果是第一次登陆的话，要在本地运行npm login，登陆一下。 $npm login Username: (你注册的时候的Username) Email: (你的注册邮箱) 4.3 运行npm publish发布包，发布之后去官网(npm)搜一下你的包是否发布成功。 发布过程中你可能会遇到错误： error 1： 使用cnpm的报错处理方法： 换回npm的镜像 npm config set registry http://registry.npmjs.org //发布之后改回淘宝镜像就好了 npm config set registry https://registry.npm.taobao.org error 2: 邮箱未认证处理方法： 去官网登陆后，会弹出一个是否发送邮箱的认证，点击发邮箱去自己的邮箱点击链接认证，然后再发布就好了 其他错误： 遇到其他错误的话，google查一下。 5. 用自己刚刚发布的包 5.1 在本地新建一个空目录，然后 npm install (你发布的包名) 5.2 新建index.js，内容： var test = require(&#39;你的包名&#39;); test.showMsg(); 5.3 node index.js 5.4 运行结果： This is my first module 恭喜你成功了","categories":[],"tags":[{"name":"npm","slug":"npm","permalink":"rychou.github.io/tags/npm/"}]},{"title":"C++中的引用转化为C语言的指针","slug":"2017-11-27","date":"2017-11-27T13:02:49.000Z","updated":"2017-11-29T15:07:23.279Z","comments":true,"path":"2017/11/27/2017-11-27/","link":"","permalink":"rychou.github.io/2017/11/27/2017-11-27/","excerpt":"C++中引用符号&amp;转化为C语言的指针*的方法最近在写数据结构上机作业时，在网上借鉴(抄)其他人的源代码时，发现有些C语言代码中夹杂着C++的代码，比如这个C++的引用符&amp;就让我很头疼，因为C中没有引用这个概念。其实在C++中是可以完美运行的，但是我又不想在C++里运行，就想怎样让其在C中运行呢。经过百般努力，终于成功了。","text":"C++中引用符号&amp;转化为C语言的指针*的方法最近在写数据结构上机作业时，在网上借鉴(抄)其他人的源代码时，发现有些C语言代码中夹杂着C++的代码，比如这个C++的引用符&amp;就让我很头疼，因为C中没有引用这个概念。其实在C++中是可以完美运行的，但是我又不想在C++里运行，就想怎样让其在C中运行呢。经过百般努力，终于成功了。 typedef struct{ Triple data[MAXSIZE+1]; int rpos[MAXRC+1]; int mu,nu,tu; }RLSMatrix; Status InitSMatrix(RLSMatrix &amp;M,RLSMatrix &amp;N){ int p; for(p=1;p&lt;=M-&gt;tu;p++){ printf(&quot;输入行号：&quot;); scanf(&quot;%d&quot;,&amp;M.data[p].i); printf(&quot;输入列号：&quot;); scanf(&quot;%d&quot;,&amp;M.data[p].j); printf(&quot;输入元素值：&quot;); scanf(&quot;%d&quot;,&amp;M.data[p].e); } ..... } void main(){ RLSMatrix M N; InitSMatrix(M,N); } 上面这段是在C++里的代码，&amp;指的是引用。这代码在C中是跑不起来的，接下来我们做一些改动，让它在C语言跑起来 typedef struct{ Triple data[MAXSIZE+1]; int rpos[MAXRC+1]; int mu,nu,tu; }RLSMatrix; Status InitSMatrix(RLSMatrix *M,RLSMatrix *N){//&amp;换为* int p; for(p=1;p&lt;=M-&gt;tu;p++){ printf(&quot;输入行号：&quot;); scanf(&quot;%d&quot;,&amp;M-&gt;data[p].i);//.换成-&gt; printf(&quot;输入列号：&quot;); scanf(&quot;%d&quot;,&amp;M-&gt;data[p].j);//.换成-&gt; printf(&quot;输入元素值：&quot;); scanf(&quot;%d&quot;,&amp;M-&gt;data[p].e);//.换成-&gt; } ..... } void main(){ RLSMatrix M N; InitSMatrix(&amp;M,&amp;N);//对M,N取址&amp; } 这样我们的代码就可以在C中完美运行啦！！！","categories":[],"tags":[{"name":"C++ C","slug":"C-C","permalink":"rychou.github.io/tags/C-C/"}]},{"title":"学习React的心理路程","slug":"React-Study","date":"2017-11-15T13:52:16.000Z","updated":"2017-11-15T14:06:59.498Z","comments":true,"path":"2017/11/15/React-Study/","link":"","permalink":"rychou.github.io/2017/11/15/React-Study/","excerpt":"","text":"教程链接 React视频教程,密码：8dwj React中文文档 一个网友写的比较好的教程 心路历程一开始直接看老师发过来的一些电子书，看到前面一两章已经初步了解到React的强大，但是不能自己动手实践做一些demo感觉还是很虚，单纯看书也记不住。所以就自己找了一些网课的教程，其中一个就是文章开头贴上去的视频教程。视频里面有5个部分左右吧，每个部分都是直接动手写demo，并且边写边给你解释。刚开始我就是照着视频里的demo一点点写下来（切忌复制黏贴源码，虽然感觉看懂了，但是记忆不深刻），慢慢的就入门了。遇到问题再去网上找，查文档。总结下来我学习的过程就是：看视频—&gt;写视频里的demo—&gt;遇到不懂的问题，网上搜、查文档 最后的建议个人感觉入门一个语言不应该直接硬着头皮去看文档，应该直接动手写demo，写的过程中肯定会遇到很多问题，当你想方设法解决了这些问题之后，自然而然就入门了。(●’◡’●)加油！！！","categories":[],"tags":[]},{"title":"Js中splice()于slice()的区别","slug":"Javascript","date":"2017-11-06T15:48:33.000Z","updated":"2017-11-29T15:07:01.571Z","comments":true,"path":"2017/11/06/Javascript/","link":"","permalink":"rychou.github.io/2017/11/06/Javascript/","excerpt":"splice() 方法与 slice() 方法的作用是不同的，splice() 方法会直接对数组进行修改,可以删除元素，也可以插入元素。而slice()是返回已有数组中的选定元素，可以截取字符串。","text":"splice() 方法与 slice() 方法的作用是不同的，splice() 方法会直接对数组进行修改,可以删除元素，也可以插入元素。而slice()是返回已有数组中的选定元素，可以截取字符串。 splice()语法array.splice(start) array.splice(start, deleteCount) array.splice(start, deleteCount, item1, item2, ...) 示例 var myFish = [&quot;angel&quot;, &quot;clown&quot;, &quot;mandarin&quot;, &quot;surgeon&quot;]; //从第 2 位开始删除 0 个元素，插入 &quot;drum&quot; var removed = myFish.splice(2, 0, &quot;drum&quot;); //运算后的 myFish:[&quot;angel&quot;, &quot;clown&quot;, &quot;drum&quot;, &quot;mandarin&quot;, &quot;surgeon&quot;] //被删除元素数组：[]，没有元素被删除 //从第 3 位开始删除 1 个元素 removed = myFish.splice(3, 1); //运算后的myFish：[&quot;angel&quot;, &quot;clown&quot;, &quot;drum&quot;, &quot;surgeon&quot;] //被删除元素数组：[&quot;mandarin&quot;] //从第 2 位开始删除 1 个元素，然后插入 &quot;trumpet&quot; removed = myFish.splice(2, 1, &quot;trumpet&quot;); //运算后的myFish: [&quot;angel&quot;, &quot;clown&quot;, &quot;trumpet&quot;, &quot;surgeon&quot;] //被删除元素数组：[&quot;drum&quot;] //从第 0 位开始删除 2 个元素，然后插入 &quot;parrot&quot;, &quot;anemone&quot; 和 &quot;blue&quot; removed = myFish.splice(0, 2, &quot;parrot&quot;, &quot;anemone&quot;, &quot;blue&quot;); //运算后的myFish：[&quot;parrot&quot;, &quot;anemone&quot;, &quot;blue&quot;, &quot;trumpet&quot;, &quot;surgeon&quot;] //被删除元素的数组：[&quot;angel&quot;, &quot;clown&quot;] //从第 3 位开始删除 2 个元素 removed = myFish.splice(3, Number.MAX_VALUE); //运算后的myFish: [&quot;parrot&quot;, &quot;anemone&quot;, &quot;blue&quot;] //被删除元素的数组：[&quot;trumpet&quot;, &quot;surgeon&quot;] slice()语法array.slice(start, end) 示例 在数组中读取元素： var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Lemon&quot;, &quot;Apple&quot;, &quot;Mango&quot;]; var citrus = fruits.slice(1,3); 输出： Orange,Lemon 截取字符串 var str=&quot;www.runoob.com!&quot;; document.write(str.slice(4)+&quot;&lt;br&gt;&quot;); // 从第 5 个字符开始截取到末尾 document.write(str.slice(4,10)); // 从第 5 个字符开始截取到第10个字符","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"rychou.github.io/tags/Javascript/"}]},{"title":"给页面添加一个密码验证","slug":"给页面添加一个密码验证","date":"2017-10-18T16:05:29.000Z","updated":"2017-11-29T15:06:32.101Z","comments":true,"path":"2017/10/19/给页面添加一个密码验证/","link":"","permalink":"rychou.github.io/2017/10/19/给页面添加一个密码验证/","excerpt":"文章的密码验证今天写博客的时候想着要些一些日记之类的博客的话，如果没有密码验证那就不叫日记了，所以在网上找了一下方法，下面是我根据别人的改进的js代码,加在文章中可以实现密码验证","text":"文章的密码验证今天写博客的时候想着要些一些日记之类的博客的话，如果没有密码验证那就不叫日记了，所以在网上找了一下方法，下面是我根据别人的改进的js代码,加在文章中可以实现密码验证直接附上源码 &lt;script&gt; while(1){ if(&quot;123456&quot;==prompt(&quot;请输入密码！(123456)&quot;)) { break; } else { alert(&quot;输入错误&quot;); } } &lt;/script&gt; 注意事项： 使用时将该段代码放到文章开头，否则就会不起效果。什么意思呢？看下面图片就知道了。 看到了吧，如果放在文章末尾的话，就会先加载js代码前面的部分，也就是文章内容，所以说，为了防止这种情况发生，得把js代码放在文章开头 不过这个代码还是不完善的，比如说如果你的主题主页不是单纯的列表页的话，那么你在主页就会出现这个密码验证。所以说不完善，博主还在想办法完善中。不过我朋友找到一个插件可以设置密码，下面是我朋友的博客文章https://bababadboy.github.io/2017/10/18/AES%E5%8A%A0%E5%AF%86hexo%E6%96%87%E7%AB%A0/ while(1){ if(\"123456\"==prompt(\"请输入密码！(123456)\")) { break; } else { alert(\"输入错误\"); } }","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"rychou.github.io/tags/hexo/"}]},{"title":"hexo建站的坑","slug":"hexo建站的坑","date":"2017-10-18T15:14:05.000Z","updated":"2017-11-29T15:07:12.748Z","comments":true,"path":"2017/10/18/hexo建站的坑/","link":"","permalink":"rychou.github.io/2017/10/18/hexo建站的坑/","excerpt":"Hexo的安装与使用这是我的第一篇博客，刚开始想弄jekyll的，但是弄了很久也没配置好，干脆直接弄hexo了。接下来讲讲我弄hexo的遇到的一些问题吧。这是一个我看到的一个比较好的教程","text":"Hexo的安装与使用这是我的第一篇博客，刚开始想弄jekyll的，但是弄了很久也没配置好，干脆直接弄hexo了。接下来讲讲我弄hexo的遇到的一些问题吧。这是一个我看到的一个比较好的教程大家在配置好后，在本地运行一般没有问题，但是在推到Github上去的时候， $ hexo deploy Error：Deployer not found: git 我就遇到了这里出错的问题，在网上看了解决办法发现只需要在你的Blog的根目录下运行一下代码 npm install hexo-deployer-git --save 然后再 $ hexo generate $ hexo deploy 然后everything is ok！","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"rychou.github.io/tags/hexo/"}]}]}